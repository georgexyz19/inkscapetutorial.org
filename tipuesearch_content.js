var tipuesearch = {"pages":[{"title":"About","text":"About This website is about Inkscape software and its extension development. The site first becomes live on 9/1/2021. The website is freely hosted on github pages. Front end web framework: Bootstrap. Python static site generator: Pelican. Article search tool: Tipue Search. Contact: georgexyz19 at gmail Feel free to send a pull request to the github repo: https://github.com/georgexyz19/inkscapetutorial.org.git User extension source code is listed in this github repo: https://github.com/georgexyz19/inkscape-user-extension.git","tags":"pages","url":"https://www.inkscapetutorial.org/pages/about.html","loc":"https://www.inkscapetutorial.org/pages/about.html"},{"title":"Code Projects","text":"Setup Inkscape in Windows and Ubuntu It is a little difficult for beginners to figure out how to customize Inkscape. This article discusses the steps to customize Inkscape in both Windows and Ubuntu.","tags":"pages","url":"https://www.inkscapetutorial.org/pages/articles.html","loc":"https://www.inkscapetutorial.org/pages/articles.html"},{"title":"Extension Tutorial","text":"This series of articles are developed from my personal notes. I will add more contents to this page overtime. Feel free to contact me if you have good ideas for new articles (9/1/2021).","tags":"pages","url":"https://www.inkscapetutorial.org/pages/extension.html","loc":"https://www.inkscapetutorial.org/pages/extension.html"},{"title":"Inkscape Tutorial","text":"Inkscape Tutorial Inkscape Tutorial for Engineers, 12 slides in PDF for learning Inkscape. Inkscape has become my favorite drawing tool after designing with a commercial CAD (computer-aided design) software package for several years. Most of my work drawings nowadays are designed in Inkscape. It is truly an amazing piece of open software. Inkscape users can be roughly divided into two groups of people. The first group includes artists and creative people who use Inkscape to produce creative work. The Inkscape 1.1 about screen is a perfect example and it's an amazing piece of art work. The second group of people uses Inkscape to produce technical drawings. Those users may treat Inkscape as a downgraded version of a CAD tool, or an upgraded version of a basic drawing tool. This set of slides is mainly designed for the second group of users. This set of 12 slides is created in Inkscape when I am learning the software. It helps me become familiar with Inkscape and later serves as a reference for myself. I hope you will find them useful. Download PDF Inkscape Selector The first tool on the toolbar is selector, and it has three modes: single click, double click, and second click. SVG Code Scalable Vector Graphics ( SVG ) has six shape elements: line, rectangle, circle, ellipse, polyline, and polygon. Inkscape itself has special attributes for shapes like star. Inkscape Node Inkscape has four types of node: corner, smooth, symmetric, and auto. Pen tool is very versatile and it has five modes we can use. Last updated March 2019 This website contains many Inkscape materials and notes from my blog site. This set of slides was developed in 2019 with Inkscape version 0.92. We will revise it to reflect the current version 1.1. (9/1/2021) Dmitry Kirsanov's The Book of Inkscape (2nd ed) is recently published. This is an excellent book to learn Inkscape software.","tags":"pages","url":"https://www.inkscapetutorial.org/pages/inkscape-tutorial.html","loc":"https://www.inkscapetutorial.org/pages/inkscape-tutorial.html"},{"title":"Setup Inkscape in Windows and Ubuntu","text":"Inkscape software is easy to install in both Windows and Ubuntu. However it is a little difficult for beginners to figure out how to customize the software. This article discusses the steps to customize Inkscape in both Windows and Ubuntu. Windows Setup Inkscape official website has a portable version. You can download a 7-zip file from this official download page . Click the third download button under text \"Binary archive in 7zip format (64bit)\" to down a .7z file. A free utility software 7-zip is able to extract .7z file into a directory. The 7-zip software also has a portable version if you do not want to install it. After the file is extracted into this directory, double clicking bin\\inkscape.exe or Run Inkscape! file starts Inkscape. C:\\Users\\<username>\\Documents\\inkscape-1.1-x64\\inkscape Inkscape User Extension Directory In Inkscape, click menu item Edit > Preferences to open preference dialog (Ctrl + Shift + p). Choose System on the left, and the right side shows system paths for variables. The default value for User extensions is, C:\\Users\\<username>\\AppData\\Roaming\\inkscape\\extensions Open this location in File Explorer and copy and paste extension files (.py and .inx) into the directory. The extension programs will show up under Extensions top level menu next time Inkscape starts. Or you can change the location to a different directory. Fonts There are two ways to customize fonts in Inkscape. The first one is to copy font files into C:\\Windows\\Fonts directory. The fonts become accessible to all Windows programs. You can find and download online .ttf font files such as popular Roboto fonts. The second way is to create a new fonts directory at the location where Inkscape folder is extracted, and copy files into this fonts directory. Open file \\etc\\fonts\\conf.d\\50-user.conf and add a line <dir>./fonts</dir> before the last line. Check the new fonts on Text and Font dialog in Inkscape. ... <dir>./fonts</dir> </fontconfig> Ubuntu Setup In Ubuntu 21.04, bash command sudo apt install inkscape installs Inkscape 1.0.2 as of 9/1/2021. If you want the latest stable version 1.1, this omg ubuntu web page provides more information. You add a ppa repository first and then type the same bash command to install. sudo add-apt-repository ppa:inkscape.dev/stable-1.1 sudo apt install inkscape To add fonts in Ubuntu, we create a .fonts subdirectory in the home directory and copy font files into it. The fonts will become available in Inkscape. Custom Settings Inkscape has lots of settings that users can customize. However, a few default settings do not work very well, and it is suggested to change them. We can access Preference dialog via menu Edit > Preference or keyboard shortcut Ctrl + Shift + p . We suggest changing Bounding box to use from Visual bounding box to Geometric bounding box . The setting is under Tools on the left panel. The default Dialog behavior is Dockable under Interface/Widnows panel. We suggest changing it to Floating to be more consistent with other Windows programs.","tags":"posts","url":"https://www.inkscapetutorial.org/inkscape-setup.html","loc":"https://www.inkscapetutorial.org/inkscape-setup.html"},{"title":"Arrowhead Extension","text":"Problem The Dimensions system extension discussed in Chapter 14 adds markers as arrowheads. Marker element is an SVG concept and it has a stroke width which causes the arrowhead to extend beyond leading line. When we zoom in to the arrowheads, they look like this. If we manually set the marker stroke width to zero, we would have another problem. The tip of the arrowhead is on the top of dimension line, and the arrowhead doesn't look good (shown below). What is the right way to draw an arrowhead? We should offset the start point of the dimension line by a distance d , so the arrowhead itself will cover the dimension line. Marker elements are often difficult to manipulate in Inkscape, so we will draw a filled path as arrowhead. This sounds like something that an Inkscape extension can do. Let's create the arrowhead extension. Arrowheads A simple arrowhead can be determined by two variables—angle (A) and length (L). The angle is between two side lines (red) and the length is from the tip to the back of arrowhead (blue). The extension will support two shapes sharp and normal as shown below. Sometimes we need an arrowhead at one end of a path and other times we need it at both ends. The extension will support adding arrowhead at the begin, at the end, or at both ends. When we draw a straight line in Inkscape with the Bezier tool, the d attribute could have values like the values shown below. The begin point is the coordinate after the M (Move), and end point is the second coordinate or a calculated coordinate based on values after H (Horizontal) or V (Vertical). Note the begin point could be on the right or top of end point. M 104.51948,88.538059 143.37506,72.466987 M 173.74472,28.097683 H 204.0094 M 183.58612,45.030754 V 74.30451 The dialog box below shows the extension user interface. When we use the extension, we need to draw a line on the canvas, have the line selected, and click the Custom -> Draw Arrowhead menu, choose the values on the dialog and click apply. The extension Python code will add an arrowhead to the drawing and modify the selected path. The draw_arrowhead.inx file contains the extension GUI code and draw_arrowhead.py is the extension Python file. Optimum Arrowhead Angles What are the optimum arrowhead angles? The experiment drawing below shows all arrowheads with angles between 15 and 50 degrees with a 2.5 degree increment. Arrowheads with angle 25 or 30 look nice and most arrowheads on my drawings have either 25 or 30 degree angles. The Python file arrowhead_angle.py is used to generate this drawing. Modify Dimensions Extension We can modify the dimensions extension and use the arrowheads discussed in this chapter. The drawing below shows the same figure discussed in Chapter 14. When we zoom in to the arrowheads, the tip of the arrowhead aligns well with the leading lines. The revised code is in the custom_dimensions.py file. Others The extension program includes code to handle a two segment path. When we are working on a drawing, we often need to add arrowhead to such path. The current arrowhead program is still simple and straightforward. It could become complicated. The current program does not handle curves, and adding curve support will become challenging. The code makes changes to the path, and we could save the original path information in the arrowhead element and retrieve it when we need it later.","tags":"extension","url":"https://www.inkscapetutorial.org/arrowhead-extension.html","loc":"https://www.inkscapetutorial.org/arrowhead-extension.html"},{"title":"Selection","text":"Selection One piece of information which Inkscape sends to an extension is selected elements. The extension receives ids of selected elements as command line arguments from Inkscape. For example, we have a drawing with 4 selected elements as shown below. When we click the apply button on an extension user interface, the extension receives 4 \"--id=…\" values as shown in the sys.argv variable below. sys argv: ['hello.py', '--id=rect1125', '--id=path1149', '--id=path1253', '--id=path1358', '--name=inkscape', '/tmp/ink_ext_XXXXXX.svgUBQJ80'] The id values are the id attributes of selected elements. Because the id attribute is unique for each element, the extension knows which elements are selected. The inkex uses argparse Python standard library module to parse arguments. The code is in the __init__ method of SvgInputMixin class (inkex/base.py module). self.arg_parser.add_argument( \"--id\", action=\"append\", type=str, dest=\"ids\", default=[], help=\"id attribute of object to manipulate\") self.arg_parser.add_argument( \"--selected-nodes\", action=\"append\", type=str, dest=\"selected_nodes\", default=[], help=\"id:subpath:position of selected nodes, if any\") The selected ids will become a list which is accessed as self.options.ids in an extension. self.options : Namespace(input_file='/tmp/ink_ext_XXXXXX.svgUBQJ80', output=None, name='inkscape', ids=['rect1125', 'path1149', 'path1253', 'path1358'], selected_nodes=[]) When inkex loads an SVG file, it will set an instance variable selection on the SvgDocumentElement class object. The selection variable is of type ElementList and its value is set in the load method of SvgInputMixin class. self.svg = document.getroot() self.svg.selection.set(*self.options.ids) ElementList Class The ElementList class is defined in the inkex/elements/_selected.py module. Even though it is called ElementList , it subclasses OrderedDict and it's a dictionary. When we iterate through an instance variable, it iterates through the values of the dictionary and the class acts like a list. The values of the dictionary are the selected element objects. We would think that keys of the dictionary are the ids of selected elements and the values are the corresponding element objects. However, the keys are actually xml_path of selected element. The xml_path is a property defined in the BaseElement class and it calls the getpath method of ElementTree class. The lxml documentation describes that \"[getpath method] returns a structural, absolute XPath expression to find the element\". ElementList key is a string value. It's the value before the colon as shown below. The first part /* refers to the svg element. The second part /*[3] refers to g layer element nested inside svg . The g element is listed after sodipodi:namedview and defs elements. The third part /*[1] refers to the rect element, which is the first one nested under g element. # ELementList dict format: xml_path to element /*/*[3]/*[1] : rect /*/*[3]/*[2] : ellipse /*/*[3]/*[3] : path /*/*[3]/*[4] : path The ElementList class also defines an ids instance variable, which is a dictionary mapping id to xml_path . The class also has a method id_dict which returns a dictionary mapping id to element . Why does the class choose to use xml_path value as the dictionary key? It is probably for the paint_order method which returns a list of selected elements by z-order (bottom to top). One very useful method in the ElementList class is filter . We can filter out the elements by type. The method return a new ElementList object containing only the element with certain type. The code below shows an example, and the selected_elems contains only path elements. from inkex import PathElement select_elems = self.svg.selection.filter(PathElement) The bounding_box method returns a BoundingBox object for selected elements. It's useful when we need to know the size of selected elements such as the Dimensions extension. Inkscape itself preserves the selection order when passing the ids to an extension. The first element in the ElementList is the first selected element in Inkscape. The extension system doesn't provide a way to transmit selected elements back to Inkscape, so we can't modify selections in an Inkscape extension. Selected Nodes Similar to selected elements, Inkscape also passes selected nodes to extensions. In inkscape we use the node selection tool to select nodes on a path. For example, the drawing below shows that the first two nodes are selected (blue square dots). When we click the apply button on an extension interface, the extension receives several --selected-nodes=... arguments. The argument values are in a format shown below. The help message of add_argument indicates it is in id:subpath:position format. Notice the subpath and position values are both zero based here. [‘path3535:0:1', ‘path3535:0:0'] Searching through the system extension directory, the selected-nodes values are not used in any extensions. However, it might be useful when we need to deal with path nodes in extensions.","tags":"extension","url":"https://www.inkscapetutorial.org/selection.html","loc":"https://www.inkscapetutorial.org/selection.html"},{"title":"Paths","text":"PathElement Class The PathElement class represents a path element on a drawing. The class is defined in the inkex/elements/_polygons.py module. It is derived from PathElementBase class. Both classes only include a few methods and properties. The Python interpreter session below shows how to get hold of a path element and invoke its methods and properties. The same drawing drawing-21.svg discussed in Chapter 9 is used here as an example. The path element is a typical Bezier curve with two end points and two control points. george@Inspiron-5515:~$ /usr/bin/python3 Python 3.9.5 (default, May 11 2021, 08:20:37) [GCC 10.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> >>> import sys >>> sys.path.append('/usr/share/inkscape/extensions') >>> >>> from inkex import load_svg >>> et = load_svg('/home/george/Desktop/drawing-21.svg') >>> svg = et.getroot() >>> >>> for el in svg: ... print(el) ... namedview defs g >>> >>> gel = svg[-1] >>> gel <Element {http://www.w3.org/2000/svg}g at 0x7fc6ecd069a0> >>> >>> for el in gel: ... print(el) ... rect ellipse path path >>> >>> pel = gel[-1] >>> >>> pel <Element {http://www.w3.org/2000/svg}path at 0x7fc6ecd06b30> >>> >>> pel.original_path [Move(80.3412, 87.9089), Curve(99.575, 67.2665, 103.398, 73.9063, 113.129, 83.6942)] >>> >>> pel.path # defined in ShapeElement [Move(80.3412, 87.9089), Curve(99.575, 67.2665, 103.398, 73.9063, 113.129, 83.6942)] >>> >>> pel.__class__ <class 'inkex.elements._polygons.PathElement'> >>> >>> pel.get_path() 'M 80.341223,87.908862 C 99.574968,67.266473 103.39751,73.906308 113.12895,83.694219' >>> >>> pel.get('d') 'M 80.341223,87.908862 C 99.574968,67.266473 103.39751,73.906308 113.12895,83.694219' >>> >>> Path Class The path property defined in ShapeElement class returns a Path object. Other classes derived from ShapeElement also have this path property. The Path class is defined in inkex/paths.py module. The Path object is interesting, and it is a list of other class objects. The inkex/paths.py module defines many other classes such as Move , move , Horz , horz , Curve , curve , etc. >>> p = pel.path >>> p [Move(80.3412, 87.9089), Curve(99.575, 67.2665, 103.398, 73.9063, 113.129, 83.6942)] >>> p.bounding_box() BoundingBox((80.341223, 113.12895),(74.37224453581157, 87.908862)) >>> >>> for pt in p.control_points: ... print(pt) ... 80.3412, 87.9089 99.575, 67.2665 103.398, 73.9063 113.129, 83.6942 >>> >>> for pt in p.end_points: ... print(pt) ... 80.3412, 87.9089 113.129, 83.6942 >>> >>> >>> p.reverse() [Move(113.129, 83.6942), Curve(103.398, 73.9063, 99.575, 67.2665, 80.3412, 87.9089)] >>> >>> from inkex import Transform >>> p.transform(Transform('translate(10,10)')) # return changed value [Move(90.3412, 97.9089), Curve(109.575, 77.2665, 113.398, 83.9063, 123.129, 93.6942)] >>> >>> p.to_absolute() [Move(80.3412, 87.9089), Curve(99.575, 67.2665, 103.398, 73.9063, 113.129, 83.6942)] >>> >>> str(p) 'M 80.3412 87.9089 C 99.575 67.2665 103.398 73.9063 113.129 83.6942' >>> >>> p_str = str(p) >>> from inkex import Path >>> p_new = Path(p_str) >>> p_new [Move(80.3412, 87.9089), Curve(99.575, 67.2665, 103.398, 73.9063, 113.129, 83.6942)] >>> p_new.__str__() 'M 80.3412 87.9089 C 99.575 67.2665 103.398 73.9063 113.129 83.6942' >>> >>> m = p_new[0] >>> m Move(80.3412, 87.9089) >>> m.args (80.3412, 87.9089) >>> >>> m.x = 80 >>> m.y = 88 >>> m Move(80, 88) It is easy to create a Path element from composing class objects. Here is an example to create a similar Bezier curve as shown above and add it to a drawing in memory. >>> from inkex.paths import Move, Curve >>> p2 = Path() >>> m = Move(90, 90) >>> p2.append(m) >>> c = Curve(99, 67, 104, 74, 114, 84) >>> p2.append(c) >>> p2 [Move(90, 90), Curve(99, 67, 104, 74, 114, 84)] >>> >>> from inkex import PathElement >>> pel = PathElement.new(p2) >>> pel <Element {http://www.w3.org/2000/svg}path at 0x7fc6ecd06e50> >>> gel <Element {http://www.w3.org/2000/svg}g at 0x7fc6ecd069a0> >>> gel.append(pel) >>> for el in gel: ... print(el) ... rect ellipse path path path # new path element Path Related Extensions Inkscape comes with many path related system extensions. They are listed under Modify Path , Generate From Path , and Visualize Path submenus under Extensions menu. Let's examine one of them and discuss its code. When we work on engineering drawings, the dimension tool is indispensable. The Dimensions menu under Visualize Path is such a tool. We can select several path elements or a single element and apply the extension. The extension will draw the auxiliary lines and two dimension lines with arrow heads. However, the tool does not automatically add dimension texts along the lines. The figure below shows an example. The Dimensions extension code is in the dimension.inx and dimension.py files under system extension directory. The Dimension class is derived from PathModifier class in pathmodifier.py module, which is in turn derived from EffectExtension class. The Dimension class doesn't use any methods in PathModifier class, so it is the same as subclassing EffectExtension class directly. The Dimension class defines 5 methods. We have discussed add_arguments and effect methods in previous chapters. The other three methods add_marker , horz_line , vert_line are easy to understand.","tags":"extension","url":"https://www.inkscapetutorial.org/paths.html","loc":"https://www.inkscapetutorial.org/paths.html"},{"title":"Drawings For Practice","text":"The previous chapters cover most contents of Inkscape extension development. This chapter will describe some drawing ideas for practice. We could manually draw those figures in Inkscape, but the point here is to practice extension programming skills. Pythagoras's Theorem Chapter 2 of Bill Casselman's book Mathematical Illustrations book has a drawing (on Page 5) which shows the \"graphic proof\" of the Pythagoras's theorem. The Pythagoras's theorem is, For a right angled triangle with short sides a and b and long side c, c&#94;2 = a&#94;2 + b&#94;2 Let's generate the same drawing in an Inkscape extension. The SVG drawing is shown below. The code is available on the github repository for this website. American Flag Bill Casselman's book Chapter 5 Exercise 5.4 (on Page 5) is to draw an American flag. This webpage lists the US Flag Specifications. Write an extension to generate the flag drawing.","tags":"extension","url":"https://www.inkscapetutorial.org/drawings-for-practice.html","loc":"https://www.inkscapetutorial.org/drawings-for-practice.html"},{"title":"Inkex Element Classes","text":"All element classes like Polyline and TextElement are directly or indirectly derived from BaseElement class, which is defined in the inkex/elements/_base.py module. The BaseElement class is subclassed from etree.ElementBase class. The etree.ElementBase class is described as \"public Element class\" in its documentation page . The BaseElement defines an __init_subclass__ magic method which will register all its subclasses and add them to a lookup_table defined in NodeBasedLookup class. When the XML parser starts parsing a document, it will use this lookup_table to find the appropriate custom element class for each element. It probably can be implemented as a class decorator in Python, but every BaseElement subclass needs to be decorated with the decorator. class BaseElement(etree.ElementBase): \"\"\"Provide automatic namespaces to all calls\"\"\" def __init_subclass__(cls): if cls.tag_name: NodeBasedLookup.register_class(cls) Here is a class hierarchy diagram for some element classes. SvgDocumentElement Class When we load an SVG document into memory with inkex module, the root element is an SvgDocumentElement class object. Let's draw some shapes on canvas, save the SVG file, and load it. The drawing has 4 simple elements as shown below. The load_svg function is defined in the inkex/elements/_base.py module. The function invokes etree.parse method to load the SVG file. The return value is an ElementTree object. As discussed in the last chapter, we can call the getroot method to get a top level Element object, which is the svg tag element. The svg tag element is actually of type SvgDocumentElement , which is a subclass of etree._Element class. george@Inspiron-5515:~$ /usr/bin/python3 Python 3.9.5 (default, May 11 2021, 08:20:37) [GCC 10.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import sys >>> sys.path.append('/usr/share/inkscape/extensions') >>> from inkex import load_svg >>> et = load_svg('/home/george/Desktop/drawing-21.svg') >>> et <lxml.etree._ElementTree object at 0x7f3d0f71ca80> >>> svg = et.getroot() >>> svg.tag '{http://www.w3.org/2000/svg}svg' >>> svg.__class__ <class 'inkex.elements._svg.SvgDocumentElement'> >>> from lxml import etree >>> from inkex import BaseElement >>> isinstance(svg, etree.ElementBase) True >>> isinstance(svg, etree._Element) True >>> issubclass(etree.ElementBase, etree._Element) True The Element class object is iterable. When we loop through the object, we can print out child tag names. The four shape elements are nested inside the g layer object, and we can loop through the layer object to print 4 element tag names. The interesting part of the results shown below is that each element nested inside the svg tag has an svg namespace unless it is specified with an explicit namespace such as sodipodi:namedview . >>> len(svg) 3 >>> for el in svg: ... print(el.tag) ... {http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd}namedview {http://www.w3.org/2000/svg}defs {http://www.w3.org/2000/svg}g >>> gel = svg[-1] # group >>> gel.tag '{http://www.w3.org/2000/svg}g' >>> len(gel) 4 >>> for el in gel: ... print(el.tag) ... {http://www.w3.org/2000/svg}rect {http://www.w3.org/2000/svg}ellipse {http://www.w3.org/2000/svg}path {http://www.w3.org/2000/svg}path The SvgDocumentElement class is defined in the inkex/elements/_svg.py module. The class defines an _init method, which is called once during Element class instantiation time. Other methods and properties are not hard to understand. Here are some examples. >>> svg.get_ids() {'svg5', 'rect31', 'path55', 'layer1', 'path159', 'path274', 'defs2', 'namedview7'} >>> >>> svg.get_unique_id('rect31') 'rect318029' >>> >>> svg.get_ids() {'svg5', 'rect31', 'path55', 'layer1', 'path159', 'path274', 'rect318029', 'defs2', 'namedview7'} >>> >>> svg. get_page_bbox() BoundingBox((0, 210.0),(0, 297.0)) >>> >>> svg.get_current_layer() <Element {http://www.w3.org/2000/svg}g at 0x7f3d0ccfabd0> >>> >>> svg.getElementById('path55') <Element {http://www.w3.org/2000/svg}ellipse at 0x7f3d0c0ebdb0> >>> svg.getElementByName('Layer 1') <Element {http://www.w3.org/2000/svg}g at 0x7f3d0ccfabd0> >>> >>> svg.name 'drawing-21.svg' >>> >>> svg.namedview <Element {http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd}namedview at 0x7f3d0c0ebbd0> >>> >>> svg.get_viewbox() [0.0, 0.0, 210.0, 297.0] >>> >>> svg.width 210.0 >>> svg.height 297.0 >>> svg.scale 1.0 >>> svg.unit 'mm' >>> svg.stylesheets [] >>> svg.stylesheet [] BaseElement Class The BaseElement class is defined in the inkex/elements/_base.py module. All element classes derive from the BaseElement class, and the methods and properties are designed for different types of elements. The class defines a WRAPPED_ATTRS class variable, and a wrapped_attrs property, which returns a dictionary. >>> svg.wrapped_attrs {'transform': ('transform', <class 'inkex.transforms.Transform'>), 'style': ('style', <class 'inkex.styles.Style'>), 'class': ('classes', <class 'inkex.styles.Classes'>)} The BaseElement class defines __setattr__ and __getattr__ magic methods. They add support for three nested attributes: transform , style , and class . For example, we can assign a string value to the transform property. The __setattr__ method will convert it to an Transform class object and assign it to the property. >>> rel = gel[0] >>> rel.transform Transform(((1, 0, 0), (0, 1, 0))) >>> rel.transform ='translate(10, 10) rotate(30)' >>> rel.transform Transform(((0.866025, -0.5, 10), (0.5, 0.866025, 10))) >>> rel.transform ='scale(2)' >>> rel.transform Transform(((2, 0, 0), (0, 2, 0))) The BaseElement class also defines set and get methods. Both methods add namespace support. When we set an attribute with a namespace like inkscape:label , the set method will convert the namespace inkscape to a long string {http...} . The update method calls the set method to set attributes, and the new method calls the update method. So both new and update methods support nested attributes and namespaces. The pop method deletes an existing attribute. >>> rel.set('inkscape:label', 'rectangle') >>> rel.attrib {'id': 'rect31', 'width': '43.4631', ... '{http://www.inkscape.org/namespaces/inkscape}label': 'rectangle'} >>> rel.update(width='40', inkscape__label='rect1') # double underscore as sep >>> rel.attrib {'id': 'rect31', 'width': '40', ... '{http://www.inkscape.org/namespaces/inkscape}label': 'rect1'} >>> rel.pop('inkscape:label') 'rect1' Other notable methods in the class are shown in the example code below. >>> from inkex import Group >>> gel_new = Group . new ( 'newgroup' ) # create a new group obj >>> gel_new . tostring () b '<g inkscape:label=\"newgroup\"/>' >>> gel . add ( gel_new ) < Element { http : // www . w3 . org / 2000 / svg } g at 0x7f3d0ccfa630 > >>> for el in gel : ... print ( el . tag ) ... { http : // www . w3 . org / 2000 / svg } rect { http : // www . w3 . org / 2000 / svg } ellipse { http : // www . w3 . org / 2000 / svg } path { http : // www . w3 . org / 2000 / svg } path { http : // www . w3 . org / 2000 / svg } g >>> gel_new . set_random_id () >>> gel_new . eid 'g1675' >>> gel_new . get_id () 'g1675' >>> gel_new . set_id ( 'g1678' ) >>> gel_new . eid 'g1678' >>> gel_new . root < Element { http : // www . w3 . org / 2000 / svg } svg at 0x7f3d0f7229a0 > >>> >>> gel . descendants () ElementList ([( '/*/*[3]' , < Element { http : // www . w3 . org / 2000 / svg } g at 0x7f3d0ccfabd0 > ), ( '/*/*[3]/*[1]' , < Element { http : // www . w3 . org / 2000 / svg } rect at 0x7f3d0c0ebd60 > ), ... ) >>> gel_new . ancestors () ElementList ([( '/*/*[3]' , < Element { http : // www . w3 . org / 2000 / svg } g at 0x7f3d0ccfabd0 > ), ( '/*' , < Element { http : // www . w3 . org / 2000 / svg } svg at 0x7f3d0f7229a0 > )]) >>> svg . findone ( 'g' ) # return nothing >>> svg . findone ( 'svg:g' ) < Element { http : // www . w3 . org / 2000 / svg } g at 0x7f3d0ccfabd0 > >>> svg . findone ( '//svg:rect' ) < Element { http : // www . w3 . org / 2000 / svg } rect at 0x7f3d0c0ebd60 > >>> svg . findall ( '//svg:rect' ) # not sure why error, a bug? Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > File \"/usr/share/inkscape/extensions/inkex/elements/_base.py\" , line 389 , in findall return super () . findall ( pattern , namespaces = namespaces ) File \"src/lxml/etree.pyx\" , line 1558 , in lxml . etree . _Element . findall File \"src/lxml/_elementpath.py\" , line 334 , in lxml . _elementpath . findall File \"src/lxml/_elementpath.py\" , line 312 , in lxml . _elementpath . iterfind File \"src/lxml/_elementpath.py\" , line 281 , in lxml . _elementpath . _build_path_iterator SyntaxError : cannot use absolute path on element >>> svg . xpath ( '//svg:rect' ) [ < Element { http : // www . w3 . org / 2000 / svg } rect at 0x7f3d0c0ebd60 > ] >>> svg . xpath ( '//svg:path' ) [ < Element { http : // www . w3 . org / 2000 / svg } path at 0x7f3d0c0ebea0 > , < Element { http : // www . w3 . org / 2000 / svg } path at 0x7f3d0c0eb9f0 > ] >>> gel_new . delete () >>> for el in gel : ... print ( el . tag ) ... { http : // www . w3 . org / 2000 / svg } rect { http : // www . w3 . org / 2000 / svg } ellipse { http : // www . w3 . org / 2000 / svg } path { http : // www . w3 . org / 2000 / svg } path >>> >>> gel [ - 1 ] . replace_with ( gel_new ) >>> for el in gel : ... print ( el . tag ) ... { http : // www . w3 . org / 2000 / svg } rect { http : // www . w3 . org / 2000 / svg } ellipse { http : // www . w3 . org / 2000 / svg } path { http : // www . w3 . org / 2000 / svg } g >>> >>> str ( svg ) # call __str__ method 'svg' >>> >>> gel . add ( gel_new . copy ()) < Element { http : // www . w3 . org / 2000 / svg } g at 0x7f3d0c0ff400 > >>> >>> [ str ( el ) for el in gel ] # this is a better way to see children [ 'rect' , 'ellipse' , 'path' , 'g' , 'g' ] >>> >>> >>> gel_new . duplicate () < Element { http : // www . w3 . org / 2000 / svg } g at 0x7f3d0c0ff450 > >>> >>> [ str ( el ) for el in gel ] [ 'rect' , 'ellipse' , 'path' , 'g' , 'g' , 'g' ]","tags":"extension","url":"https://www.inkscapetutorial.org/inkex-element-classes.html","loc":"https://www.inkscapetutorial.org/inkex-element-classes.html"},{"title":"Colors and Styles","text":"SVG Styles The SVG specs has a chapter on styling . The SVG and Cascading Style Sheets ( CSS ) share many styling properties. There are two ways to style an element in SVG . We can style an element using individual attributes or combining them together as the value of style attribute. For example, we can create a blue rectangle with red border like this. <rect fill= \"blue\" stroke= \"red\" stroke-width= \"2\" x= \"10\" y= \"10\" width= \"30\" height= \"20\" /> Or we can specify a single style attribute like this. <rect style= \"fill:blue; stroke:red; stroke-width:3\" x= \"50\" y= \"50\" width= \"30\" height= \"20\" /> SVG elements generated by Inkscape itself use the style attribute. Style Module The style.py module in inkex directory defines several classes. The most notable one is the Style class which derives from OrderedDict class. The __init__ method of the class is written in a way that it accepts a dictionary, a string, key value pairs, or another Style object as the initial value. The Python interpreter session below shows how to initialize a Style object in different ways. george@Inspiron-5515:~$ /usr/bin/python3 >>> import sys >>> sys.path.append('/usr/share/inkscape/extensions') >>> from inkex import Style >>> s = Style({'fill':'red', 'stroke':'green'}) >>> s Style([('fill', 'red'), ('stroke', 'green')]) >>> str(s) 'fill:red;stroke:green' >>> st1 = Style('fill:red; stroke:green') >>> str(st1) 'fill:red;stroke:green' >>> st2 = Style(fill='red', stroke='green') >>> str(st2) 'fill:red;stroke:green' >>> st3 = Style(st2) >>> str(st3) 'fill:red;stroke:green' The static method parse_str parses a string and yields key value pair as a tuple from which we can create a new Style object. The to_str method converts a Style object to a string. The update method is similar to Python dictionary update method. The Style class also defines the __add__ and __sub__ methods so we can add or subtract Style class objects. The operators + or - create new copies of Style object. >>> st4 = Style({'stroke-width':'3'}) >>> st5 = st3 + st4 >>> print(st5) fill:red;stroke:green;stroke-width:3 >>> st6 = st5 - {'fill':'red'} >>> print(st6) stroke:green;stroke-width:3 The Style class also defines a get_color and a set_color method. We can use them like the examples shown below. >>> st6.get_color('stroke') [0, 128, 0, 1.0] >>> st6.set_color('red', 'fill') >>> print(st6) stroke:green;stroke-width:3;fill:#ff0000 When we are working on element style in an Inkscape extension, we change the element style in Inkscape itself and watch the style value in XML editor. Once we find a value to use, we can set the same style attribute and value in extension code. As shown in previous chapters, we set style property of an element object with a Style object. element . style = st2 # st2 is a Style object Color Module The colors.py module in inkex directory defines an SVG_COLOR dictionary with 148 color names and values. The is_color function determines if a value is a color that we can use. >>> from inkex.colors import SVG_COLOR >>> len ( SVG_COLOR ) # include a none 149 >>> SVG_COLOR [ 'none' ] >>> from inkex.colors import is_color >>> is_color ( '#334' ) True >>> is_color ( '#334srd' ) # wrong value above F False >>> is_color ( '#33AABB' ) True >>> is_color ( 'red' ) True >>> is_color ( 345 ) True >>> is_color ( '#334ABD00' ) # this is in rgba format True We usually use the color name as a string value such as red or an RGB string value such as #FF00CC when we specify a color in extension code. ColorExtension Class The Inkscape has a whole class of extensions dealing with colors. They are listed under the Extensions > Color menu. The Randomize and Negative are interesting, and Grayscale and Replace color are sometimes useful. Those extensions have classes derived from ColorExtension class which is defined in the extensions.py module. Let's take a look at the Grayscale extension. The content of the color_grayscale.py module is listed below. It only overrides a modify_color method. The color argument is the color of the element to be modified. The name argument is one of the color attribute names stroke , fill , stop-color , flood-color or lighting-color defined in the Style class. The return value is the new modified color. #!/usr/bin/env python \"\"\"Convert to grey\"\"\" import inkex class Grayscale ( inkex . ColorExtension ): \"\"\"Make all colours grayscale\"\"\" def modify_color ( self , name , color ): # ITU-R Recommendation BT.709 (NTSC and PAL) # l = 0.2125 * r + 0.7154 * g + 0.0721 * b lum = 0.299 * color . red + 0.587 * color . green + 0.114 * color . blue return inkex . Color (( int ( round ( lum )), int ( round ( lum )), int ( round ( lum )))) if __name__ == '__main__' : Grayscale () . run ()","tags":"extension","url":"https://www.inkscapetutorial.org/colors-and-styles.html","loc":"https://www.inkscapetutorial.org/colors-and-styles.html"},{"title":"Transforms","text":"Equations When we move an element from one location to another location on Inkscape canvas, we can also view it as moving an imaginary coordinate system with it. The element stays at the same location in the imaginary coordinate system. Translate, rotate, and scale are three common transforms in Inkscape. The translate transform is simply moving an object. The coordinate of a point on the object (x, y) will change to (x', y'). The a and b values in the equations shown below represent the distances along X and Y axes the object has moved. If we write two equations below in matrix form, we have the third equation. The two equations below are for rotation and scale. The rotation angle (alpha) is clockwise because the y axis increases from top to bottom. The a and b of the scale equation represent the scale factor along X and Y. The above rotation equation is for rotating around the origin (0, 0). If we rotate an element around a coordinate (a, b), the equation becomes like this. The matrix is in this form when those three transforms are combined. Inkscape Transforms Let's look at an example to see how the transform works in Inkscape. First we draw a rectangle with top left coordinates (10, 10). It has a width of 60 and height of 40. The SVG file has these lines for the element. We can ignore the id and style attributes for this example. <rect style= \"fill:none;stroke:#000000; stroke-width:0.26458333;stop-color:#000000\" id= \"rect31\" width= \"60\" height= \"40\" x= \"10\" y= \"10\" /> We will use the transform dialog (Menu Object -> Transform or shortcut Ctrl + Shift + M) to see how Inkscape handles a transform. When we move the rectangle 10mm horizontally and 10mm vertically (with Relative move selected), the SVG element coordinates will change. <rect width= \"60\" height= \"40\" x= \"20\" y= \"20\" /> Next let's rotate the object 30 degrees clockwise. The element code becomes like this. It will have a new transform attribute with rotate(30) as its value. The x and y coordinate values change from (20, 20) to (33.3012, -10.3589). The reason is that the rotation is not around the origin (0, 0), instead it is around the center of the rectangle which is (50, 40). How does Inkscape calculate the new coordinates of the top left corner of the rectangle? It is a little complicated, and this numpy python script shows the calculation. <rect width= \"60\" height= \"40\" x= \"33.30127\" y= \"-10.358984\" transform= \"rotate(30)\" /> The rotate function as the value of the transform attribute can also accept two additional arguments as the rotation center. The xml code shown below represents the same rectangle. <rect width= \"60\" height= \"40\" x= \"20\" y= \"20\" transform= \"rotate(30, 50, 30)\" /> The SVG specs define other transform functions translate , scale , skewX , skewY , and matrix . We can also add a transform attribute to a group or a layer. Transform in Extension Code The transform.py module in the inkex directory has over 1,000 lines of code. But the system extensions do not use this function very often. Only a few system extensions set the transform attribute. Here is a simple extension to test the transform attribute of the rectangle element. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <inkscape-extension xmlns= \"http://www.inkscape.org/namespace/inkscape/extension\" > <name> Transform Element </name> <id> user.transform </id> <effect> <object-type> all </object-type> <effects-menu> <submenu name= \"Custom\" /> </effects-menu> </effect> <script> <command location= \"inx\" interpreter= \"python\" > transform.py </command> </script> </inkscape-extension> # transform.py import inkex from inkex import Rectangle , Transform class NewElement ( inkex . GenerateExtension ): container_label = 'transform' container_layer = True def generate ( self ): self . style = { 'fill' : 'none' , 'stroke' : '#000000' , 'stroke-width' : self . svg . unittouu ( '1px' )} rects = self . add_rect () for r in rects : yield r def add_rect ( self ): el1 = Rectangle ( x = '10' , y = '10' , width = '60' , height = '40' ) el1 . style = self . style el2 = Rectangle . new ( 20 , 20 , 60 , 40 ) el2 . style = self . style tr = Transform ( 'rotate(30)' ) el2 . transform = tr el3 = Rectangle . new ( 20 , 20 , 60 , 40 ) el3 . style = self . style tr = Transform ( 'rotate(30, 50, 40)' ) el3 . transform = tr el4 = Rectangle . new ( 20 , 20 , 60 , 40 ) el4 . style = self . style tr = Transform ( 'translate(10, 10) rotate(45)' ) el4 . transform = tr el5 = Rectangle . new ( 20 , 20 , 60 , 40 ) el5 . style = self . style tr = Transform ( 'scale(2.0) rotate(60)' ) el5 . transform = tr el6 = Rectangle . new ( 20 , 20 , 60 , 40 ) el6 . style = self . style tr = Transform ( 'rotate(60)' ) * Transform ( 'scale(2.0)' ) el6 . transform = tr return el1 , el2 , el3 , el4 , el5 , el6 if __name__ == '__main__' : NewElement () . run () Notice in the above examples, we can combine multiple transforms as the string argument to the Transform constructor, or multiply multiple Transform objects. The SVG results are shown below. <rect x= \"10\" y= \"10\" width= \"60\" height= \"40\" id= \"rect1007\" /> <rect x= \"20\" y= \"20\" width= \"60\" height= \"40\" transform= \"rotate(30)\" id= \"rect1009\" /> <rect x= \"20\" y= \"20\" width= \"60\" height= \"40\" transform= \"matrix(0.866025 0.5 -0.5 0.866025 26.6987 -19.641)\" id= \"rect1011\" /> <rect x= \"20\" y= \"20\" width= \"60\" height= \"40\" transform= \"matrix(0.707107 0.707107 -0.707107 0.707107 10 10)\" id= \"rect1013\" /> <rect x= \"20\" y= \"20\" width= \"60\" height= \"40\" transform= \"matrix(1 1.73205 -1.73205 1 0 0)\" id= \"rect1015\" /> <rect x= \"20\" y= \"20\" width= \"60\" height= \"40\" transform= \"matrix(1 1.73205 -1.73205 1 0 0)\" id= \"rect1017\" /> Other Classes The transforms module also includes several other classes and functions. The notable classes are Vector2d , BoundingBox , and DirectedLineSegment . It also defines two functions cubic_extrema and quadratic_extrema . Those classes and functions are not necessarily related to transforms . The Vector2d and DirectedLineSegment classes are very useful when we are working on mathematical drawings. We can apply vector algebra to calculate coordinates of points, and draw them as lines or polygons on the canvas. References Anthony J. Pettofrezzo published two books Vectors and Their Applications and Matrices And Transformations . Both books are relevant to the transforms module discussed in this chapter. The book Mathematical Illustrations, A Manual Of Geometry and Postscript by Bill Casselman is an excellent reference for math drawings. Here is the link to the book webpage. The pdfs of the book chapters are available on the webpage. The book Introduction To Computer Graphics by James Foley and others has a Chapter Geometrical Transformations. The transform equations in this book are in the same format as on this page.","tags":"extension","url":"https://www.inkscapetutorial.org/transforms.html","loc":"https://www.inkscapetutorial.org/transforms.html"},{"title":"Units and Coordinate Systems","text":"Extension Units Inkscape extension documentation page has a units page. Inkscape units themselves are not complicated, and the difficult part is how Inkscape projects units in user coordinate system to viewport coordinate system. Most common units in Inkscape are pixel, point, millimeter, and inch. The inkex/units.py module defines a CONVERSIONS dictionary. The base unit is pixel or px . The dictionary value is the converting factor from other unit to px . For example, 1 in equals 96.0 px , and 1 point or pt equals 1.3333 px . # a dictionary of unit to user unit conversion factors CONVERSIONS = { 'in' : 96.0 , 'pt' : 1.3333333333333333 , 'px' : 1.0 , 'mm' : 3.779527559055118 , 'cm' : 37.79527559055118 , 'm' : 3779.527559055118 , 'km' : 3779527.559055118 , 'Q' : 0.94488188976378 , 'pc' : 16.0 , 'yd' : 3456.0 , 'ft' : 1152.0 , '' : 1.0 , # Default px } When we are working on a drawing, we often use different units to describe different elements. We describe the line stroke width as 1px or 2px , line length as 20mm or 1.5in , font size as 12pt or 10pt , paper size as letter (8.5in x 11in) in the US , or A4 (210mm x 297mm). The 1px stroke width is an commonly picked number. If we want narrower width, 0.75px is a good choice. We can choose 1.5px or 2px width when we need a bolder line. Microsoft Word default font is 11pt Calibri, and it was 12pt Times New Roman in earlier versions. An 10pt font size is still considered legible when printed on paper, and smaller font size is often considered too tiny to read. Coordinate Systems When we create a Line element and add it to the drawing, we usually do not need to specify a unit for line length. For example, here is the code for el11 in previous chapter. el1 = Line () el1 . set ( 'x1' , '10' ) el1 . set ( 'y1' , '10' ) el1 . set ( 'x2' , '40' ) el1 . set ( 'y2' , '40' ) el1 . set ( 'style' , self . style ) We do not need to specify the units for the SVG file either. The default A4 page SVG file has those lines. <svg width= \"210mm\" height= \"297mm\" viewBox= \"0 0 210 297\" What do those numbers mean? The width and height attributes of svg tag mean the Inkscape canvas size. It is also called viewport coordinate system . It is on the right hand side of the following drawing. The default size 210mm x 297mm is the same size of a piece of A4 page. When we export the drawing to an PDF file, it will have the same size. If we print the PDF file on a piece of A4 paper, it is supposed to be 100% of the PDF . When we create a line from (10, 10) to (40, 40), the coordinates are in the user coordinate system or user space . It is on the left hand size of the above drawing. The user coordinate system origin and size are defined as the viewBox attribute of svg tag. The viewBox attribue values (0 0 210 297) also do not have units. What are the units of those values? The svg specification says that the default user space unit is pixel . If we set the line start point as (10px, 10px) and end point as (40px, 40px) the result will be the same. However, the line will show up on the canvas as from (10mm, 10mm) to (40mm, 40mm) because line is mapped from user coordinate system to viewport coordinate system. This is confusing here. We set the coordinates in pixel, but they show up on canvas in mm . So it is better to leave the units out. el1 . set ( 'x1' , '10px' ) # same as `10` el1 . set ( 'y1' , '10px' ) # prefer no unit el1 . set ( 'x2' , '40px' ) el1 . set ( 'y2' , '40px' ) If we set the line from (10mm, 10mm) to (40mm, 40mm), it will be the same as set the coordinates from (37.795, 37.995) to (151.18, 151.18) in the user space. Inkscape will automatically convert those numbers to pixels. Unit Conversion What if we know the size of an element on canvas, what value should we set in user space? For example, we want a line with a stroke width of 1px , what value should we set for the stroke-width attribute? The stroke width of 1px is the same as 1/3.7795 = 0.2646mm . When we set the stroke-width value as 0.2646 , it will show up as 1px width on canvas. We can also call unittouu method (property) of BaseElement class to do the conversion for us. It will convert a value in viewport coordinate system to user space. This covers most of what we need to know about Inkscape units and coordinate system mapping. sw = self . svg . unittouu ( '1px' ) # sw is .2645... If we want 10pt font size text, we set the font-size to the below value. This is a more natural way to describe element sizes. fz = self . svg . unittouu ( '10pt' ) # fz value is 3.5278 You may find coordinate mapping confusing if you do not have prior experiences on computer graphics system. The Inkscape 1.0 changes the y-axle of the viewport coordinate system to increase fom top to bottom, and origin to the top left corner. Before Inkscape 1.0, the origin is at the bottom left corner. You can imagine that the coordinate systems are even more confusing then. Units Module The inkex/units.py Python module is independent of other modules, so it's easy to understand code in this module. Let's experiment the module in Python interpreter. Start the python interpreter with /usr/bin/python3 command if the system has multiple python versions installed. This is the system Python with lxml module installed. george@Inspiron-5515:~$ /usr/bin/python3 Python 3.9.5 (default, May 11 2021, 08:20:37) [GCC 10.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. If we simply import inkex , the interpreter can't find where the module is located. We can add the path to the sys.path . >>> import inkex Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > ModuleNotFoundError : No module named 'inkex' >>> import sys >>> sys . path . append ( '/usr/share/inkscape/extensions' ) >>> import inkex >>> dir ( inkex . units ) [ ... ] >>> help ( inkex . units ) The help(inkex.units) command will show the functions defined in the module and a short description for each function. are_near_relative(point_a, point_b, eps=0.01) Return true if the points are near to eps convert_unit(value, to_unit, default='px') Returns user units given a string representation of units in another system discover_unit(value, viewbox, default='px') Attempt to detect the unit being used based on the viewbox parse_unit(value, default_unit='px', default_value=None) Takes a value such as 55.32px and returns (55.32, ‘px') Returns default (None) if no match can be found render_unit(value, unit) Checks and then renders a number with its unit It is nice to have source code available. But it is easier for us to understand how to use those functions through examples. We can grep the Inkscape system extensions to find out how they are used. >>> from inkex import units >>> p = units . parse_unit ( '55.32px' ) >>> p ( 55.32 , 'px' ) >>> p = units . parse_unit ( '55.32pt' ) >>> p ( 55.32 , 'pt' ) >>> p = units . parse_unit ( '55.32bt' ) >>> p # returns None >>> p = units . parse_unit ( '55.32' ) >>> p ( 55.32 , 'px' ) # default unit is pixel >>> units . are_near_relative ( 0.123 , 0.121 ) False >>> units . are_near_relative ( 0.123 , 0.122 ) True >>> units . are_near_relative ( 0.1234 , 0.1232 ) True >>> units . discover_unit ( '210mm' , 210 , default = 'px' ) 'mm' >>> units . discover_unit ( '8.5in' , 210 , default = 'px' ) 'px' # default >>> units . discover_unit ( '8.5in' , 215.9 , default = 'px' ) 'mm' # letter size >>> units . convert_unit ( '8.5in' , 'mm' ) 215.9 >>> units . render_unit ( 10 , 'in' ) '10in' >>> units . convert_unit ( '8.5' , 'mm' ) 2.2489583333333334 >>> units . convert_unit ( '1px' , 'mm' ) 0.26458333333333334 >>> units . convert_unit ( '10pt' , 'mm' ) 3.5277777777777777","tags":"extension","url":"https://www.inkscapetutorial.org/units-and-coordinate-systems.html","loc":"https://www.inkscapetutorial.org/units-and-coordinate-systems.html"},{"title":"Custom Shape Elements","text":"Custom Element Classes The inkex module defines many custom element classes. The Python files are under the inkex/elements directory and module names all start with an underscore _ . It indicates that those are internal modules and we should not directly import those modules. When inkex module loads an SVG file, it uses those custom element classes and returns objects of custom element class instead of generic Element class of lxml . The inkex module creators did the hard work of writing custom element classes. It currently has 64 classes included in Inkscape 1.1 release. Here are a few examples. inkex.elements._meta.Defs inkex.elements._meta.StyleElement inkex.elements._svg.SvgDocumentElement inkex.elements._groups.Layer inkex.elements._polygons.PathElement inkex.elements._polygons.Polyline inkex.elements._polygons.Polygon inkex.elements._polygons.Line inkex.elements._polygons.Rectangle inkex.elements._polygons.Circle ...... If an SVG file contains an rect shape element, it will become an Rectangle object in memory when inkex loads and parses the file. When we write user extensions, we can create objects of those custom element classes, and add them to a containing element such as layer or group. Let's take a look at the PathElement inheritance tree. The class is derived from ShapeElement which in turn is derived from BaseElement class. etree.ElementBase BaseElement ShapeElement PathElement Create New Elements The code in the Hello extension shows the typical way to add new elements to a drawing. We create an element object first, set some attributes, and add the element to a containing group or layer. The new element will become part of the drawing. The example below shows how to add shape and text elements to a drawing. Here are the contents in the newelement.inx file. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <inkscape-extension xmlns= \"http://www.inkscape.org/namespace/inkscape/extension\" > <name> New Element </name> <id> user.newelement </id> <effect> <object-type> all </object-type> <effects-menu> <submenu name= \"Custom\" /> </effects-menu> </effect> <script> <command location= \"inx\" interpreter= \"python\" > newelements.py </command> </script> </inkscape-extension> Save the following code in a newelement.py file under user extension directory. import inkex from inkex import Line , Polyline , Polygon , Rectangle , Circle , \\ Ellipse , PathElement from inkex import TextElement class NewElement ( inkex . EffectExtension ): def effect ( self ): self . style = { 'fill' : 'none' , 'stroke' : '#000000' , 'stroke-width' : '0.264583' } self . text_template = \\ 'font-size: %d px;text-align:center;text-anchor:middle;' layer = self . svg . get_current_layer () layer . add ( * self . add_line (), * self . add_rect ()) layer . add ( self . add_circle (), self . add_ellipse (), self . add_polygon (), self . add_path ()) layer . add ( * self . add_coordinates ()) def add_line ( self ): el1 = Line () el1 . set ( 'x1' , '10' ) el1 . set ( 'y1' , '10' ) el1 . set ( 'x2' , '40' ) el1 . set ( 'y2' , '40' ) el1 . set ( 'style' , self . style ) el2 = Line . new ( start = ( 40 , 10 ), end = ( 10 , 40 )) el2 . style = self . style el3 = Line () el3 . update ( ** { 'x1' : '50' , 'y1' : '10' , 'x2' : '80' , 'y2' : '40' , 'style' : self . style }) el4 = Line ( x1 = '50' , y1 = '40' , x2 = '80' , y2 = '10' ) el4 . style = self . style return el1 , el2 , el3 , el4 def add_rect ( self ): el1 = Rectangle ( x = '10' , y = '60' , width = '30' , height = '20' ) el1 . style = self . style el2 = Rectangle . new ( 50 , 60 , 30 , 20 ) el2 . style = self . style return el1 , el2 def add_circle ( self ): el = Circle . new ( center = ( 105 , 25 ), radius = 15 ) el . style = self . style return el def add_ellipse ( self ): el = Ellipse . new ( center = ( 105 , 70 ), radius = ( 15 , 10 )) el . style = self . style return el def add_polygon ( self ): el = Polygon () el . set ( 'points' , '130,10 160,10 160,25 145,25 145,40 130,40' ) el . style = self . style return el def add_path ( self ): el = PathElement () el . set ( 'd' , 'M 130,60 h30 v10 h-15 v10 h-15 z' ) el . style = self . style return el def add_text ( self , x , y , position = 'top' , font_size = 3.88 ): text = TextElement () x0 , y0 = x , y # adjust y position if position == 'top' : y = y - 2 elif position == 'bottom' : y = y + 4 else : y = y text . set ( 'x' , x ) text . set ( 'y' , y ) text . set ( 'style' , self . text_template % font_size ) text . set ( 'xml:space' , 'preserve' ) text . text = f '( { x0 } , { y0 } )' return text def add_coordinates ( self ): coordinates = [ ( 10 , 10 ), ( 40 , 40 , 'bottom' ), ( 40 , 10 ), ( 10 , 40 , 'bottom' ), ( 50 , 10 ), ( 80 , 40 , 'bottom' ), ( 50 , 40 , 'bottom' ), ( 80 , 10 , 'top' ), ( 105 , 25 , 'top' ), ( 105 , 70 , 'top' ), ( 10 , 60 , 'top' ), ( 50 , 60 , 'top' ), ( 130 , 10 , 'top' ), ( 130 , 60 , 'top' ), ( 160 , 10 , 'top' ), ( 160 , 60 , 'top' ), ] text_elements = [ self . add_text ( * c ) for c in coordinates ] circle_elements = [ self . generate_circle ( c [ 0 ], c [ 1 ]) \\ for c in coordinates ] return text_elements + circle_elements def generate_circle ( self , x , y , r = 0.66145 ): circle_style = 'fill:#000000;stroke:none;stroke-width:0.264583' el = Circle . new ( center = ( x , y ), radius = r ) el . style = circle_style return el if __name__ == '__main__' : NewElement () . run () Click the menu Extensions -> Custom -> NewElement to create elements on the current layer of a drawing. The drawing below shows the results. The code logic is simple. The add_line method of the NewElement class shows four way to create a new Line element and set its attributes. The set method of an element such as el1 seems to be the most straightforward way to set attributes. The custom element classes do not have a custom __init__ method. This is due to a requirement from lxml because they are inherited from ElementBase . GenerateExtension Class Many system extensions like render_gears and render_barcode inherit from GenerateExtension class. The class itself is a subclass of EffectExtension , and it already has code to add elements to the drawing. The source code is in the inkex/extensions.py module. When we inherit from this class, we only need to override the generate method. Here is an example of using GenerateExtension to create four lines. We do not need to write any code to deal with layers. The example below creates a new lines layer and adds new elements to the layer. This is determined by the two class variables container_label and container_layer . import inkex from inkex import Line class NewElement ( inkex . GenerateExtension ): container_label = 'lines' container_layer = True def generate ( self ): self . style = { 'fill' : 'none' , 'stroke' : '#000000' , 'stroke-width' : '0.264583' } lines = self . add_lines () for l in lines : yield l def add_lines ( self ): el1 = Line () el1 . set ( 'x1' , '10' ) el1 . set ( 'y1' , '10' ) el1 . set ( 'x2' , '40' ) el1 . set ( 'y2' , '40' ) el1 . set ( 'style' , self . style ) el2 = Line . new ( start = ( 40 , 10 ), end = ( 10 , 40 )) el2 . style = self . style el3 = Line () el3 . update ( ** { 'x1' : '50' , 'y1' : '10' , 'x2' : '80' , 'y2' : '40' , 'style' : self . style }) el4 = Line ( x1 = '50' , y1 = '40' , x2 = '80' , y2 = '10' ) el4 . style = self . style return el1 , el2 , el3 , el4 if __name__ == '__main__' : NewElement () . run () Inkex SVG Parsing When we load an XML file into memory, we usually use the default XML parser that comes with lxml module. doc = etree.parse('test.xml') Or you can invoke the etree.XMLParser method to create a parser and pass the parser object to etree.parse method. The huge_tree option shown below \"disables security restrictions and supports deep trees and long text content\". p = etree.XMLParser(huge_tree=True) doc = etree.parse('test.xml', parser=p) The lxml documentation has a page regarding using custom Element classes in lxml . The \"Tree based element class lookup in Python\" section has an example like this. class MyLookup(etree.PythonElementClassLookup): def lookup(self, document, element): return MyElementClass parser = etree.XMLParser() parser.set_element_class_lookup(MyLookup()) The MyLookup class must have a method lookup as shown above. The document argument of the lookup method acts like self.document object and the element argument acts like an Element object. The return value MyElementClass is a custom class defined elsewhere which must inherit from etree.ElementBase class. The code in the elements/_base.py module follows this pattern to define the lookup class NodeBasedLookup . It creates a custom parser SVG_PARSER and defines the load_svg method which uses the parser. With the parser in place, the return value from etree.parse method will contain Rectangle class object instead of general Element object if it is an rect shape element. This is a simplification. It actually is a Python proxy object because lxml.etree is based on libxml2, which loads the XML tree into memory in a C structure.","tags":"extension","url":"https://www.inkscapetutorial.org/shape-classes.html","loc":"https://www.inkscapetutorial.org/shape-classes.html"},{"title":"lxml Basics","text":"What is lxml The Inkscape SVG files are in xml format. When we write an Inkscape extension, we could write the code to parse the xml, modify the content, and send it back to Inkscape. Or we can use other well designed and tested code for xml parsing and handling. Generally speaking, reusing other people's existing code saves programming time. The drawback is that we have to spend time to learn how to use existing code. The lxml XML toolkit is a Python binding for the C libraries libxml2 and libxslt. It is similar to Python standard library module xml.etree.ElementTree , but it is faster and easier to program. The Inkscape extension developers long recognized the value of lxml python package. The package inkex wraps many functions of lxml so extension developers do not have to deal with lxml directly. It is usually enough for Inkscape developers to only work with inkex package. But sometimes we want to use functionality in lxml directly, or try to understand the code in inkex package, so it's better to know the basics of lxml package. Module etree Main features of lxml package are in the etree module. We will discuss several functions and classes in the etree module in this chapter. Note terms like function, method, or class constructor may not be accurate. They are all callable objects in Python. In this chapter, we simply call them functions or methods. etree.parse etree.ElementTree etree.tostring etree.fromstring etree.Element etree.SubElement etree. XML etree. XMLID The etree.parse function is the quick way to convert an XML file into an ElementTree object. The function accepts an XML file name (or file object) and an optional parser, and returns an ElementTree instance. etree . parse ( source , parser = None , base_url = None ) Here is a Python interpreter session showing how to load an SVG file. george@Inspiron-5515:~$ /usr/bin/python3 Python 3.9.5 (default, May 11 2021, 08:20:37) [GCC 10.3.0] on linux >>> from lxml import etree >>> doc = etree.parse('/home/george/Desktop/drawing-4.svg') >>> doc <lxml.etree._ElementTree object at 0x7fcbed555ac0> >>> doc.getroot() <Element {http://www.w3.org/2000/svg}svg at 0x7fcbed555d80> >>> doc.getroot().tag '{http://www.w3.org/2000/svg}svg' >>> etree.__version__ '4.6.3' The etree.ElementTree is a wrapper class around the _ElementTree class. We can call etree.ElementTree() method to create an empty document. If we pass a file name (or file object), the return value is an ElementTree instance. If we use the element argument, the file argument will be ignored. It returns an ElementTree object based on an Element object. The etree.tostring function converts an ElementTree or Element object to a string containing the XML content. The etree.fromstring function creates an Element object from a string. etree . ElementTree ( element = None , file = None , parser = None ) etree . tostring ( elem_or_tree , pretty_print = False , encoding = None ) etree . fromstring ( text , parser = None , base_url = None ) Here is an example testing those three methods. >>> et = etree.ElementTree(file='/home/george/Desktop/drawing-5.svg') >>> et <lxml.etree._ElementTree object at 0x7fcbeadd23c0> >>> etree.tostring(et) b'<!-- Created with Inkscape (http://www.inkscape.org/) --><svg ...' >>> etree.tostring(et).decode('utf8') '<!-- Created with Inkscape (http://www.inkscape.org/) --><svg ...' >>> ss = etree.tostring(et).decode('utf8') >>> etree.fromstring(ss) <Element {http://www.w3.org/2000/svg}svg at 0x7fcbea9561c0> The Element constructor creates and returns an object implementing the Element interface. The SubElement method creates a new Element object, and adds it as the next child of its parent element. It also returns the newly created element. Many Inkscape extensions use SubElement method to add new elements before version 1.0. The SubElement method has one more argument parent than the Element constructor. The namespace part of XML is a little annoying to type. Here are a few examples. etree . Element ( tag , attrib = {}, nsmap = None , ** extras ) etree . SubElement ( parent , tag , attrib = {}, nsmap = None , ** extras ) >>> from lxml import etree >>> rect = etree . Element ( 'rect' , x = '50' , y = '50' , width = '30' , height = '20' ) >>> etree . tostring ( rect ) b '<rect x=\"50\" y=\"50\" width=\"30\" height=\"20\"/>' >>> layer = etree . Element ( 'g' , attrib = { 'inkscape:label' : 'Layer 1' , 'inkscape:groupmode' : 'layer' }) Traceback ( most recent call last ): ... ValueError : Invalid attribute name 'inkscape:label' >>> INKNS = 'http://www.inkscape.org/namespaces/inkscape' >>> NSMAP = { 'inkscape' : INKNS } >>> layer = etree . Element ( 'g' , attrib = { '{ %s }label' % INKNS : 'Layer 1' , '{ %s }groupmode' % INKNS : 'layer' }, nsmap = NSMAP ) >>> etree . tostring ( layer ) b '<g xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\" inkscape : label = \"Layer 1\" inkscape : groupmode = \"layer\" /> ' >>> layer . append ( rect ) >>> etree . tostring ( layer ) b '<g xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\" inkscape : label = \"Layer 1\" inkscape : groupmode = \"layer\" > < rect x = \"50\" y = \"50\" width = \"30\" height = \"20\" /></ g > ' >>> etree . SubElement ( layer , 'rect' , attrib = { 'x' : '100' , 'y' : '100' , 'width' : '50' , 'height' : '40' }) < Element rect at 0x7ff619336740 > >>> etree . tostring ( layer ) b '<g xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\" inkscape : label = \"Layer 1\" inkscape : groupmode = \"layer\" > < rect x = \"50\" y = \"50\" width = \"30\" height = \"20\" /> < rect x = \"100\" y = \"100\" width = \"50\" height = \"40\" /></ g > ' The etree.XML function parses an XML document or fragment from a string and returns the root Element node. It is similar to the fromstring method. The etree.XMLID function parses the text and returns a tuple (root_node, id_dict). The root_node is the same value returned by the etree.XML function. The id_dict contains id-element pairs. The dictionary keys are the id attributes of all elements, and the values are the elements referenced by the id attributes. We could design an SVG file and assign an id for each element, load the file with etree.XMLID function call, and access element via the id attribute. etree . XML ( text , parser = None , base_url = None ) etree . XMLID ( text , parser = None , base_url = None ) Element Class The Element object represents a node in the XML tree. It defines many instance methods and properties. This webpage lists the Element class API . The notable Element class properties are tag and attrib . The tag is the element tag name and attrib is the element attribute dictionary. >>> el = etree . fromstring ( '<rect x=\"50\" y=\"50\" width=\"30\" height=\"20\"/>' ) >>> el < Element rect at 0x7f4b489aab40 > >>> el . tag 'rect' >>> el . attrib { 'x' : '50' , 'y' : '50' , 'width' : '30' , 'height' : '20' } The Element instance acts like a Python list, with nested elements acting as members of the list. We can loop through an Element object, and it also supports slice operation. >>> ss = '''<g xmlns:inkscape=\"http://www.inkscape.org/namespaces/inkscape\" ... inkscape:label=\"Layer 1\" inkscape:groupmode=\"layer\"> ... <rect x=\"50\" y=\"50\" width=\"30\" height=\"20\"/> ... <rect x=\"100\" y=\"100\" width=\"50\" height=\"40\"/> ... <g> ... <line x1=\"10\" y1=\"10\" x2=\"40\" y2=\"40\"/> ... <rect x=\"10\" y=\"10\" width=\"30\" height=\"20\"/> ... </g> ... </g>''' >>> et = etree . fromstring ( ss ) >>> et < Element g at 0x7ff52fe4c180 > >>> et . tag 'g' >>> for e in et : ... print ( e . tag ) ... rect rect g >>> et [ 0 : 2 ] [ < Element rect at 0x7ff532a4ab80 > , < Element rect at 0x7ff52fe50140 > ] The get and set methods retrieves and assigns an attribute value, respectively. The class also has append and insert methods like a list. The remove method deletes an element child, and clear method removes all its child elements and attributes. >>> et . get ( '{http://www.inkscape.org/namespaces/inkscape}label' ) 'Layer 1' >>> et . set ( 'id' , 'g123252' ) >>> et . get ( 'id' ) 'g123252' >>> r = etree . fromstring ( '<rect x=\"0\" y=\"0\" width=\"1\" height=\"1\"/>' ) >>> et . append ( r ) >>> [ e . tag for e in et ] [ 'rect' , 'rect' , 'g' , 'rect' ] >>> cir = etree . fromstring ( '<circle cx=\"10\" cy=\"10\" r=\"10\" />' ) >>> et . insert ( 0 , cir ) >>> [ e . tag for e in et ] [ 'circle' , 'rect' , 'rect' , 'g' , 'rect' ] >>> et . remove ( cir ) >>> [ e . tag for e in et ] [ 'rect' , 'rect' , 'g' , 'rect' ] >>> import copy >>> et_copy = copy . deepcopy ( et ) >>> et_copy . clear () >>> [ e . tag for e in et_copy ] [] >>> et_copy . tag 'g' >>> et_copy . attrib {} The getchildren method returns a list of element children. The getiterator method walks a subtree and looks for all descendants, and it also accepts a tag argument to look for a specific type of elements. The getroottree method return an ElementTree object which contains Element instance. It also has a getparent method which returns the parent element. >> del et [ - 1 ] >>> [ e . tag for e in et ] [ 'circle' , 'rect' , 'rect' , 'g' ] >>> [ e . tag for e in et . getchildren () ] [ 'circle' , 'rect' , 'rect' , 'g' ] >>> [ e . tag for e in et . getiterator () ] [ 'g' , 'circle' , 'rect' , 'rect' , 'g' , 'line' , 'rect' ] >>> [ e . tag for e in et . getiterator ( tag = 'rect' ) ] [ 'rect' , 'rect' , 'rect' ] >>> tree = e . getroottree () >>> tree < lxml . etree . _ElementTree object at 0x7ff52f59c740 > >>> et [ - 1 ] < Element g at 0x7ff52f59a4c0 > >>> et [ - 1 ] . getparent () < Element g at 0x7ff52fe4c180 > The find method searches for element children and returns a single element that matches the pattern of its path argument. The path argument is a string describing the element for which we are searching. The values are in a format like rect or g/rect . The findall method is similar to find , and it returns a list of child elements that match the pattern. But it does not search nested elements inside children. >>> r1 = et . find ( 'rect' ) >>> r1 . attrib { 'x' : '50' , 'y' : '50' , 'width' : '30' , 'height' : '20' } >>> r2 = et . find ( 'g/rect' ) >>> r2 . attrib { 'x' : '10' , 'y' : '10' , 'width' : '30' , 'height' : '20' } >>> r3 = et . findall ( 'rect' ) >>> r3 [ < Element rect at 0x7ff52f59ca80 > , < Element rect at 0x7ff52f59cbc0 > ] The xpath is the most complicated method in Element class, and it supports XPath search language. The XPath expressions support tests, operators, and functions. It works like findall in its simple form. Here are some of its common operators. / searches for child element starting from itself // searches for itself and its descendant. e1|e2 combines the elements that matches e1 and e2. @attribute returns attribute values e1[@attr=value] elements with attribute value * wildcard matches all element or all attributes >>> et . xpath ( 'rect' ) [ < Element rect at 0x7ff52f59ca80 > , < Element rect at 0x7ff52f59cbc0 > ] >>> et . xpath ( '/g' ) [ < Element g at 0x7ff52fe4c180 > ] >>> et . xpath ( '/g/rect' ) [ < Element rect at 0x7ff52f59ca80 > , < Element rect at 0x7ff52f59cbc0 > ] >>> x1 = et . xpath ( '//rect' ) >>> [ x . tag for x in x1 ] [ 'rect' , 'rect' , 'rect' ] >>> x2 = et . xpath ( '//rect|//g' ) >>> [ x . tag for x in x2 ] [ 'g' , 'rect' , 'rect' , 'g' , 'rect' ] >>> x3 = et . xpath ( '//@width' ) >>> x3 [ '30' , '50' , '30' ] >>> et . xpath ( '//rect[@width=50]' ) [ < Element rect at 0x7ff52f59cbc0 > ] >>> et . xpath ( '//@x' ) [ '50' , '100' , '10' ] >>> et . xpath ( '//rect[@x>10]' ) [ < Element rect at 0x7ff52f59ca80 > , < Element rect at 0x7ff52f59cbc0 > ] >>> et . xpath ( '/g/rect[position()=1]' ) # position is a function [ < Element rect at 0x7ff52f59ca80 > ] >>> x4 = et . xpath ( '//*' ) >>> [ x . tag for x in x4 ] [ 'g' , 'circle' , 'rect' , 'rect' , 'g' , 'line' , 'rect' ] >>> et . xpath ( '//line/@*' ) [ '10' , '10' , '40' , '40' ] Below is a function find_or_create_layer that calls the xpath method. The function searches existing layer names and returns the layer if it finds one, otherwise it creates a new layer and returns it. The function also shows how to deal with XML namespaces when we are working with lxml . def find_or_create_layer ( svg , name ): # find an existing layer or create a new layer # need import inkex at the beginning of the module layer_name = 'Layer %s ' % name path = '//svg:g[@inkscape:label=\" %s \"]' % layer_name elements = svg . xpath ( path , namespaces = inkex . NSS ) if elements : layer = elements [ 0 ] else : layer = inkex . etree . SubElement ( svg , 'g' ) layer . set ( inkex . addNS ( 'label' , 'inkscape' ), layer_name ) layer . set ( inkex . addNS ( 'groupmode' , 'inkscape' ), 'layer' ) return layer ElementTree Class Most ElementTree class methods have the same function as in Element class. The notable methods are getroot and write . The getroot method returns the root element, and it's the opposite of getroottree method of Element class. The write method serializes the ElementTree object back to XML file. >>> r = tree . getroot () >>> r < Element g at 0x7ff52fe4c180 > >>> tree . write ( '/home/george/Desktop/temp.svg' ) References Module lxml.etree official reference https://lxml.de/apidoc/lxml.etree.html Python Standard Library Module ElementTree https://docs.python.org/3.9/library/xml.etree.elementtree.html","tags":"extension","url":"https://www.inkscapetutorial.org/lxml-basics.html","loc":"https://www.inkscapetutorial.org/lxml-basics.html"},{"title":"SVG File Format","text":"SVG Format The default Inkscape file is Scalable Vector Graphics ( SVG ) format. The SVG specification is an open standard developed by the World Wide Web ( W3C ) consortium. SVG files are XML text documents and all major modern web browsers support SVG rendering. Let's create a new blank svg file and see what the code looks like. Launch Inkscape and click menu File -> New to create a new blank file, and save the file as new-drawing.svg . Open the file with a text editor (such as gedit in Ubuntu). Below is the code in the SVG file. <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> ➊ <!-- Created with Inkscape (http://www.inkscape.org/) --> <svg width= \"210mm\" height= \"297mm\" viewBox= \"0 0 210 297\" version= \"1.1\" id= \"svg15798\" inkscape:version= \"1.1 (1:1.1+202106032008+af4d65493e)\" sodipodi:docname= \"new-drawing.svg\" xmlns:inkscape= \"http://www.inkscape.org/namespaces/inkscape\" xmlns:sodipodi= \"http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd\" xmlns= \"http://www.w3.org/2000/svg\" xmlns:svg= \"http://www.w3.org/2000/svg\" > ➋ <sodipodi:namedview id= \"namedview15800\" pagecolor= \"#ffffff\" bordercolor= \"#666666\" borderopacity= \"1.0\" inkscape:pageshadow= \"2\" inkscape:pageopacity= \"0.0\" inkscape:pagecheckerboard= \"0\" inkscape:document-units= \"mm\" showgrid= \"false\" inkscape:zoom= \"0.64052329\" inkscape:cx= \"396.55076\" inkscape:cy= \"561.25984\" inkscape:window-width= \"1551\" inkscape:window-height= \"970\" inkscape:window-x= \"26\" inkscape:window-y= \"23\" inkscape:window-maximized= \"0\" inkscape:current-layer= \"layer1\" /> ➌ <defs id= \"defs15795\" /> ➍ <g inkscape:label= \"Layer 1\" inkscape:groupmode= \"layer\" id= \"layer1\" /> ➎ </svg> The first line and second line are Inkscape SVG boilerplate code. The first line inidcates this is an XML file. The second line is an XML comment. The contents of the file is wrapped inside the svg tag ➋. The opening svg tag has many attributes. The attribute xmlns:inkscape=\"http://www.inkscape...\" means that inkscape is an xml namespace. So the attribute inkscape:version=\"1.1...\" is an abbreviation for http://www.inkscape...:version=.... . Inkscape is forked from another software sodipodi , and sodipodi is still a namespace. The sodipodi:namedview ➌ is an inkscape specific tag. Inkscape will read and interpret the tag and its attributes. Other software does not have to recognize this tag. Notice it has an attribute named current-layer with value layer1 . The current layer information is saved in the SVG file. The layer1 value refers to the id of a g tag. The self.svg.namedview.center value in triangle.py (discussed in previous chapters) is also derived from this tag. The defs is an abbreviation for definitions ➍. We can store some information in a defs tag, and other tags of the same document can reference the defs tag. The g tag is a shorthand for group. SVG itself does not have layer element. Inkscape uses group tag with additional attribute groupmode to represent layers ➎. Shapes There are six basic element shapes in SVG specs: line, rect, circle, ellipse, polyline, and polygon. When we are working on a drawing in Inkscape, we can create three types rect, circle, and ellipse directly. Inkscape uses paths for other types. The example drawing below is created in Inkscape, and the SVG code is shown below. <g inkscape:label= \"Layer 1\" inkscape:groupmode= \"layer\" id= \"layer1\" > <rect id= \"rect31\" width= \"40\" height= \"30\" x= \"10\" y= \"10\" /> <ellipse id= \"path135\" cx= \"80\" cy= \"25\" rx= \"20\" ry= \"15\" /> <circle id= \"path1280\" cx= \"123.56148\" cy= \"25.414518\" r= \"14.997319\" /> <path d= \"m 11.386056,53.443756 35.2468,23.203125\" id= \"path568\" /> <path sodipodi:type= \"star\" id= \"path1777\" inkscape:flatsided= \"false\" sodipodi:sides= \"8\" sodipodi:cx= \"265.96295\" sodipodi:cy= \"215.55252\" sodipodi:r1= \"52.037506\" sodipodi:r2= \"26.018753\" sodipodi:arg1= \"0.78539816\" sodipodi:arg2= \"1.1780972\" inkscape:rounded= \"0\" inkscape:randomized= \"0\" d= \"m 302.75903,252.34859 -26.83913,-12.75788 -9.95695,27.99932 -9.95694,-27.99932 -26.83913,12.75788 12.75788, ... z\" transform= \"matrix(0.26458333,0,0,0.26458333, -3.5417846,8.6272505)\" /> <path d= \"M 88.033107,69.531115 C 108.42781,53.650369 124.06814,55.364785 141.88598,71.15598\" id= \"path2216\" sodipodi:nodetypes= \"cc\" /> </g> The star shape is an Inkscape specific element. When we open the drawing in another program, the star shape may be treated as a path element. Paths Path element is more complicated than basic shapes. It has a d attribute which consists of commands and values. The command is a single letter followed by a value or a coordinate. The uppercase command indicates parameters are absolute values, and lowercase command indicates relative values. The Mozilla SVG Tutorial has more information on paths . Here is a list of the commands. M/m Move to L/l Line to H/h Horizontal line to V/v Vertical line to Q/q Quadratic curve to T/t Smooth quadratic curve to C/c Cubic curve to S/s Smooth cubic curve to A/a elliptical arc to Z/z Close the path Inkscape itself has lots of functions built around paths. Most of those functions are listed under the top level menu Path . For example, we can choose a rectangle element and click the first sub-menu Object to Path , and the SVG tag of the element change from rect to path with correct d attribute. References This chapter covers the minimum SVG knowledge we need to know as Inkscape extension developers. There are many online resources to learn more about SVG format. The Inkscape itself is a good tool to learn SVG . We can select an element and open the XML Editor to see the code or save the SVG file and open it in a text editor. The SVG is an open standard by W3C . The Inkscape SVG follows version 1.1. The 1.1 version spec is at this link https://www.w3.org/ TR / SVG11 / . The 2.0 version is at this link https://www.w3.org/ TR / SVG2 / . O'Reilly has published a book SVG Essentials (2nd ed) . It is a decent reference book.","tags":"extension","url":"https://www.inkscapetutorial.org/svg-file-format.html","loc":"https://www.inkscapetutorial.org/svg-file-format.html"},{"title":"Hello Extension","text":"Hello User Extension We have enough discussion on the Triangle extension. Let's create a Hello user extension modeled after the Triangle . The extension has one input text field that we can enter a name. After clicking the Apply button, the extension will output Hello <name> to the current drawing. The hello.inx and hello.py files are saved under the user extension directory. Hello.inx File The Hello.inx file is very similar to the Triangle.inx as we discussed before. In fact we make a copy of the Triangle.inx file and modify it. Now we can click Extensions -> Custom -> Hello menu to launch the extension. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <inkscape-extension xmlns= \"http://www.inkscape.org/namespace/inkscape/extension\" > <name> Hello </name> <id> user.hello </id> <param name= \"name\" type= \"string\" gui-text= \"What's your name? \" > Inkscape </param> <effect> <object-type> all </object-type> <effects-menu> <submenu name= \"Custom\" /> </effects-menu> </effect> <script> <command location= \"inx\" interpreter= \"python\" > hello.py </command> </script> </inkscape-extension> Python Hello.py Code The hello.py file also doesn't have much new code than in triangle.py . The add_text method is modified from another system extension module path_number_node.py . It creates a TextElement and sets the text and style attributes. The element is then added onto the current layer via the layer.add method. The Triangle extension discussed in previous chapters essentially does the same thing. It creates an PathElement , and then the element is added to the current layer. import inkex from inkex import TextElement class Hello ( inkex . EffectExtension ): def add_arguments ( self , pars ): pars . add_argument ( '--name' , type = str , default = 'Inkscape' , dest = 'name' , help = \"name input\" ) def effect ( self ): name = 'Hello ' + self . options . name layer = self . svg . get_current_layer () x = self . svg . unittouu ( '40px' ) y = x layer . add ( self . add_text ( x , y , name )) def add_text ( self , x , y , text ): \"\"\"Add a text label at the given location\"\"\" elem = TextElement ( x = str ( x ), y = str ( y )) elem . text = str ( text ) elem . style = { 'font-size' : self . svg . unittouu ( '18pt' ), 'fill-opacity' : '1.0' , 'stroke' : 'none' , 'font-weight' : 'normal' , 'font-style' : 'normal' } return elem if __name__ == '__main__' : Hello () . run () When we are working on a user extension, we can modify the Python code and click the Apply button to run the modified code. However, if we change the content in .inx file, we have to exit and restart Inkscape for the change to take effect. Output Below is the result of running the extension. The origin (0, 0) of SVG coordinate system is the point on the top left corner. The x value increases from left to right, and y value increases from top to bottom. The text coordinate represents 40 pixel from left of the page, and 40 pixel down from top the page. The font size is set at 18 point.","tags":"extension","url":"https://www.inkscapetutorial.org/hello-extension.html","loc":"https://www.inkscapetutorial.org/hello-extension.html"},{"title":"Extensions Workflow","text":"We will discuss those two lines of code in run method of InksacpeExtension class in this chapter. self.load_raw() self.save_raw(self.effect()) Load The code of load_raw method of InkscapeExtension class is shown below. def load_raw ( self ): # type: () -> None \"\"\"Load the input stream or filename, save everything to self\"\"\" if isinstance ( self . options . input_file , str ): self . file_io = open ( self . options . input_file , 'rb' ) document = self . load ( self . file_io ) else : document = self . load ( self . options . input_file ) self . document = document We know the value of self.options.input_file is a string from last chapter, so the if part of the if...else... statement will execute. It calls the open method to create a file object, and pass it to the self.load method. The self.load method defined in the SvgInputMixin class is invoked here. Below is the code of the load method of SvgInputMixin class. def load ( self , stream ): # type: (IO) -> etree \"\"\"Load the stream as an svg xml etree and make a backup\"\"\" document = load_svg ( stream ) self . original_document = copy . deepcopy ( document ) self . svg = document . getroot () self . svg . selection . set ( * self . options . ids ) if not self . svg . selection and self . select_all : self . svg . selection = self . svg . descendants () . filter ( * self . select_all ) return document The load method in turn calls a function load_svg imported from another module. It also adds two new instance variable original_document and svg . from .elements._base import load_svg , BaseElement Here is the function load_svg definition in the inkex/elements/_base.py module. from lxml import etree ...... SVG_PARSER = etree . XMLParser ( huge_tree = True , strip_cdata = False ) SVG_PARSER . set_element_class_lookup ( NodeBasedLookup ()) def load_svg ( stream ): \"\"\"Load SVG file using the SVG_PARSER\"\"\" if ( isinstance ( stream , str ) and stream . lstrip () . startswith ( '<' )) \\ or ( isinstance ( stream , bytes ) and stream . lstrip () . startswith ( b '<' )): return etree . ElementTree ( etree . fromstring ( stream , parser = SVG_PARSER )) return etree . parse ( stream , parser = SVG_PARSER ) Here the last statement return etree.parse(...) is executed because steam is a file object, not a string or bytes type. The etree.parse method in lxml module does the actual loading work. The lxml module is not in the standard library, and it is a third part library. It will be automatically installed when we install Inkscape. We will discuss lxml module later. Modify The Triangle object has two instance variables document and svg , and both reference the same XML tree in memory. We can modify the XML tree via either of those two variables. It also saves a copy of document in original_document instance variable. The actual modification happens in the effect method of Triangle class thru the svg instance variable. def effect ( self ): tri = self . svg . get_current_layer () offset = self . svg . namedview . center self . options . s_a = self . svg . unittouu ( str ( self . options . s_a ) + 'px' ) self . options . s_b = self . svg . unittouu ( str ( self . options . s_b ) + 'px' ) self . options . s_c = self . svg . unittouu ( str ( self . options . s_c ) + 'px' ) stroke_width = self . svg . unittouu ( '2px' ) if self . options . mode == '3_sides' : s_a = self . options . s_a s_b = self . options . s_b s_c = self . options . s_c draw_tri_from_3_sides ( s_a , s_b , s_c , offset , stroke_width , tri ) ...... The first line of the method calls get_current_layer method of svg object to get an object representing current layer. The current layer information is saved in the SVG file itself. The second line get the Inkscape view center coordinates. The next four lines of code convert number unit from pixel to SVG internal default unit millimeter. For example, the s_a value is 100 px before the conversion, and the value is 26.45 mm after. In Inkscape 1 inch is 96 pixels, and 1 inch is also 25.4 mm. So the conversion is 100/96 in * 25.4 = 26.45 mm. The effect method calls draw_tri_from_3_sides function defined earlier in the module. The function in turn calls the draw_SVG_tri function to create an inkex.PathElement element and add it to the layer. We will discuss the PathElement and other SVG elements later. def draw_SVG_tri ( point1 , point2 , point3 , offset , width , name , parent ): style = { 'stroke' : '#000000' , 'stroke-width' : str ( width ), 'fill' : 'none' } elem = parent . add ( inkex . PathElement ()) elem . update ( ** { 'style' : style , 'inkscape:label' : name , 'd' : 'M ' + str ( point1 [ X ] + offset [ X ]) + ',' + str ( point1 [ Y ] + offset [ Y ]) + ' L ' + str ( point2 [ X ] + offset [ X ]) + ',' + str ( point2 [ Y ] + offset [ Y ]) + ' L ' + str ( point3 [ X ] + offset [ X ]) + ',' + str ( point3 [ Y ] + offset [ Y ]) + ' L ' + str ( point1 [ X ] + offset [ X ]) + ',' + str ( point1 [ Y ] + offset [ Y ]) + ' z' }) return elem ..... def draw_tri_from_3_sides ( s_a , s_b , s_c , offset , width , parent ): # draw a triangle from three sides (with a given offset if is_valid_tri_from_sides ( s_a , s_b , s_c ): a_b = angle_from_3_sides ( s_a , s_c , s_b ) a = ( 0 , 0 ) # a is the origin b = v_add ( a , ( s_c , 0 )) #point B is horizontal from origin c = v_add ( b , pt_on_circ ( s_a , pi - a_b )) # get point c c [ 1 ] = - c [ 1 ] offx = max ( b [ 0 ], c [ 0 ]) / 2 # b or c could be the furthest right offy = c [ 1 ] / 2 # c is the highest point offset = ( offset [ 0 ] - offx , offset [ 1 ] - offy ) # add the centre of the triangle to the offset draw_SVG_tri ( a , b , c , offset , width , 'Triangle' , parent ) else : inkex . errormsg ( 'Invalid Triangle Specifications.' ) Save This section discusses the third method call self.save_raw shown at the beginning of this chapter. The save_raw method is defined in InkscapeExtension class like this. def save_raw ( self , ret ): # type: (Any) -> None \"\"\"Save to the output stream, use everything from self\"\"\" if self . has_changed ( ret ): if isinstance ( self . options . output , str ): with open ( self . options . output , 'wb' ) as stream : self . save ( stream ) else : self . save ( self . options . output ) The method tests if the SVG file has changed via the has_changed method in SvgThroughMixin class. It converts the original_document and document objects to string and compares if they are the same. The save_raw method then calls the save method defined in SvgOutputMixin class. The code of save method is shown below. It calls the write method of output stream to transmit the modified SVG back to Inkscape. def save ( self , stream ): # type: (IO) -> None \"\"\"Save the svg document to the given stream\"\"\" if isinstance ( self . document , ( bytes , str )): document = self . document elif 'Element' in type ( self . document ) . __name__ : # isinstance can't be used here because etree is broken doc = cast ( etree , self . document ) document = doc . getroot () . tostring () # actually execute this part else : raise ValueError ( f \"Unknown type of document: { type ( self . document ) . __name__ } can not save . \") try : stream . write ( document ) except TypeError : # we hope that this happens only when # document needs to be encoded stream . write ( document . encode ( 'utf-8' )) # type: ignore Effect Method Let's go back to the two lines of code at the beginning of this chapter. self.load_raw() self.save_raw(self.effect()) The load_raw and save_raw methods are already defined in the inkex module, so we do not need to worry about them when we inherit from inkex.EffectExtension class. We only need to override the effect method. The second line of code above implies that the effect method has a return value which is then passed to the save_raw method. The effect method of Triangle class does not have a return statement, so a None value is passed to the save_raw method. The argument ret of save_raw method is passed as an argument to has_changed method. Here the has_changed method in SvgThroughMixin class is called. The SvgThroughMixin class code is listed below. The value ret is not used here, so we don't have to return a value in the effect method. class SvgThroughMixin(SvgInputMixin, SvgOutputMixin): \"\"\" Combine the input and output svg document handling (usually for effects). \"\"\" def has_changed(self, ret): # pylint: disable=unused-argument # type: (Any) -> bool \"\"\"Return true if the svg document has changed\"\"\" original = etree.tostring(self.original_document) result = etree.tostring(self.document) return original != result Python Module lxml When we develop an Inkscape extension, we don't need to care too much about load and save processes. The inkex module already has code to handle them. It actually warps around a third party python module lxml , which does the XML loading, parsing, and saving. The lxml official website has lots of useful information. We will also discuss this module in a later chapter.","tags":"extension","url":"https://www.inkscapetutorial.org/extension-workflow.html","loc":"https://www.inkscapetutorial.org/extension-workflow.html"},{"title":"How Extensions Work","text":"Class Initialization The last two lines of triangle.py files are shown below. The first line is boilerplate code. If we run this module on terminal, the Python interpreter will set the __name__ to __main__ and the code Triangle().run() will execute. if __name__ == '__main__' : Triangle () . run () The first part of the second line Triangle() initializes an instance of Triangle class. We can think of the Triangle().run() as two statements like this. t = Triangle () t . run () In this section we will discuss class initialization part t = Triangle() , and in the next section we will examine the run part t.run() . The class Triangle itself does not define an __init__ method, and the __init__ methods in superclasses will be invoked automatically. The diagram below shows the superclasses of Triangle . Both SvgInputMixin and InkscapeExtension classes have __init__ methods, and those will be invoked. Here is the code in the __init__ method of SvgInputMixin class. It simply calls add_argument method twice. The super().__init__() statement invokes __init__ method in object because super refers to object . # __init__ in SvgInputMixin class, base.py def __init__ ( self ): super () . __init__ () self . arg_parser . add_argument ( \"--id\" , action = \"append\" , type = str , dest = \"ids\" , default = [], help = \"id attribute of object to manipulate\" ) self . arg_parser . add_argument ( \"--selected-nodes\" , action = \"append\" , type = str , dest = \"selected_nodes\" , default = [], help = \"id:subpath:position of selected nodes, if any\" ) Let's look at the __init__ method in InkscapeExtension class. # __init__ in InkscapeExtension class def __init__ ( self ): # type: () -> None NSS . update ( self . extra_nss ) self . file_io = None # type: Optional[IO] self . options = Namespace () self . document = None # type: Union[None, bytes, str, etree] self . arg_parser = ArgumentParser ( description = self . __doc__ ) self . arg_parser . add_argument ( \"input_file\" , nargs = \"?\" , metavar = \"INPUT_FILE\" , type = filename_arg , default = None , help = \"Filename of the input file (default is stdin)\" ) self . arg_parser . add_argument ( \"--output\" , type = str , default = None , help = \"Optional output filename for saving \" + \"the result (default is stdout).\" ) self . add_arguments ( self . arg_parser ) localize () The NSS.update(...) line is for XML namespaces. The NSS itself is an abbreviation for Namespace Specific String . The __init__ method initializes four instance variables file_io , options , document , and arg_parser . It calls the add_argument methods of ArgumentParser class twice, and then it calls the add_arguments class method. The add_arguments method is overridden in Triangle class, so the add_arguments method in the Triangle class will be called. The method calls add_argument of ArgumentParser class seven times. Note the method name is add_argument in ArgumentParser class and it is add_arguments (notice the plural) in Triangle class. # add_argument method in Triangle class def add_arguments ( self , pars ): logging . debug ( f 'Triangle add_arguments method starts' ) ## pars . add_argument ( \"--s_a\" , type = float , default = 100.0 , help = \"Side Length a\" ) pars . add_argument ( \"--s_b\" , type = float , default = 100.0 , help = \"Side Length b\" ) pars . add_argument ( \"--s_c\" , type = float , default = 100.0 , help = \"Side Length c\" ) pars . add_argument ( \"--a_a\" , type = float , default = 60.0 , help = \"Angle a\" ) pars . add_argument ( \"--a_b\" , type = float , default = 30.0 , help = \"Angle b\" ) pars . add_argument ( \"--a_c\" , type = float , default = 90.0 , help = \"Angle c\" ) pars . add_argument ( \"--mode\" , default = '3_sides' , help = \"Side Length c\" ) logging . debug ( f 'Triangle add_arguments method ends' ) ## We can add a pair of logging statements at the beginning and end of the method to find out the call sequence. Similar logging statements are added to the two __init__ methods, and the result is shown below. DEBUG: SvgInputMixin __init__ starts DEBUG: InkscapeExtension __init__ starts DEBUG: Triangle add_arguments method starts DEBUG: Triangle add_arguments method ends DEBUG: InkscapeExtension __init__ ends DEBUG: SvgInputMixin __init__ ends The interesting part here is that the __init__ method in SvgInputMixin is called first. When the Python interpreter encounters the self.arg_parser instance variable, it can't find the definition. It suspends this __init__ method call and starts invoking __init__ method in InkscapeExtension class. It finds the instance variable definition for self.arg_parser on this line of code. self.arg_parser = ArgumentParser(description=self.__doc__) The add_arguments method starts and ends as expected because it is called within the __init__ method of InkscapeExtension . The __init__ method in InkscapeExtension class returns first, and then the __init__ method in SvgInputMixin class returns. This is something in Python I don't know until I work on this example. There are always new things to learn in Python. Run Method After the initialization, the run method is where everything happens. Here is the code of run method again in InkscapeExtension class. def run ( self , args = None , output = stdout ): # type: (Optional[List[str]], Union[str, IO]) -> None \"\"\"Main entrypoint for any Inkscape Extension\"\"\" try : if args is None : args = sys . argv [ 1 :] self . parse_arguments ( args ) if self . options . input_file is None : self . options . input_file = sys . stdin if self . options . output is None : self . options . output = output self . load_raw () self . save_raw ( self . effect ()) except AbortExtension as err : err . write () sys . exit ( ABORT_STATUS ) finally : self . clean_up () Let's take a close look at the code between try and except lines. From last chapter, we know that the sys.argv value is a list of arguments. The args value is a list starting from the second item. ['triangle.py', '--s_a=100', '--s_b=100', '--s_c=100', '--a_a=60', '--a_b=30', '--a_c=90', '--mode=3_sides', '/tmp/ink_ext_XXXXXX.svgVYXM70'] The parse_arguments method in InkscapeExtension class simply calls parse_args method of arg_parser object. The returned value is assigned to the options instance variable, which is a Namespace object. def parse_arguments ( self , args ): # type: (List[str]) -> None \"\"\"Parse the given arguments and set 'self.options'\"\"\" self . options = self . arg_parser . parse_args ( args ) After the parse_arguments method call, the self.options value is the Namespace object shown below. We can access variables in the object like a property (e.g., self.options.input_file ). Notice the ids and selected_nodes instance variables in Namespace . Inkscape passes those two values to the extension. Namespace(input_file='/tmp/ink_ext_XXXXXX.svgVJUG70', output=None, s_a=100.0, s_b=100.0, s_c=100.0, a_a=60.0, a_b=30.0, a_c=90.0, mode='3_sides', ids=[], selected_nodes=[]) The next four statements changes the self.options.output and self.options.input_file values if they are None . The self.options.input_file does not change in the Triangle example. The value /tmp/ink_ext_XXXXXX.svgVJUG70 refers to a temporary file Inkscape creates and passes to the extension. We can think of the last two lines as the three lines shown below. Upon this point, the program is working on initialization and setting up variables. These three lines of code is doing the actually work, loading the temporary svg file, modifying it, and sending it back to Inkscape. We will examine those method calls in the next chapter. self . load_raw () e = self . effect () self . save_raw ( e ) Python ArgParse Module From the above discussion, we should have a basic understanding on how Inkscape extensions work. When we launch Inkcape, it will check files under user extension and system extension directories, and create menu items under the Extensions top level menu. When we click an extension menu such as Triangle , Inkscape will setup the input and output stream of Python environment and call the Python interpreter installed at this path /usr/bin/python3 . It also passes the following arguments to the Python interpreter. ['triangle.py', '--s_a=100', '--s_b=100', '--s_c=100', '--a_a=60', '--a_b=30', '--a_c=90', '--mode=3_sides', '/tmp/ink_ext_XXXXXX.svgVYXM70'] This is similar to enter a command on a bash terminal. $/usr/bin/python3 triangle.py --s_a=100 --s_b=100 --s_c=100 \\ --a_a=60 --a_b=30 --a_c=90 --mode=3_sides \\ /tmp/ink_ext_XXXXXX.svgVYXM70 The argparse is the Python standard library module which turns command line options (like --s_a=100 ) and arguments (like /tmp/ink... ) into variables we can access ( self.options.s_a ) in the program. Python documentation site has an official argparse module tutorial . The argparse module was introduced in Python 3.4, which supersedes the optparse in Python2. The old Inkscape extensions before Inkscape 1.0 use optparse module.","tags":"extension","url":"https://www.inkscapetutorial.org/how-extensions-work.html","loc":"https://www.inkscapetutorial.org/how-extensions-work.html"},{"title":"Triangle Extension Code","text":"Extension Structure In this tutorial, we will take a look at the Triangle extension source code. Usually an Inkscape extension consists of two files—one .inx file and one .py file. The .inx file contains xml code describing the user interface and the .py file is the Python code doing the actual work. The .py file can import other modules so an extension could involve multiple Python modules. The Triangle extension code is in the triangle.inx and triangle.py files. Both files are in the system extension directory. Inx File The triangle.inx file has 27 lines. The content of the file is shown below. <?xml version=\"1.0\" encoding=\"UTF-8\"?> ➊ <inkscape-extension xmlns= \"http://www.inkscape.org/namespace/inkscape/extension\" > <name> Triangle </name> ➋ <id> math.triangle </id> ➌ <param name= \"s_a\" type= \"float\" min= \"0.01\" max= \"10000\" gui-text= \"Side Length a (px):\" > 100.0 </param> ➍ <param name= \"s_c\" type= \"float\" min= \"0.01\" max= \"10000\" gui-text= \"Side Length c (px):\" > 100.0 </param> <param name= \"a_a\" type= \"float\" min= \"0\" max= \"180\" gui-text= \"Angle a (deg):\" > 60 </param> <param name= \"a_b\" type= \"float\" min= \"0\" max= \"180\" gui-text= \"Angle b (deg):\" > 30 </param> <param name= \"a_c\" type= \"float\" min= \"0\" max= \"180\" gui-text= \"Angle c (deg):\" > 90 </param> <param name= \"s_b\" type= \"float\" min= \"0.01\" max= \"10000\" gui-text= \"Side Length b (px):\" > 100.0 </param> <param name= \"mode\" type= \"optiongroup\" appearance= \"combo\" gui-text= \"Mode:\" > ➎ <option value= \"3_sides\" > From Three Sides </option> <option value= \"s_ab_a_c\" > From Sides a, b and Angle c </option> <option value= \"s_ab_a_a\" > From Sides a, b and Angle a </option> <option value= \"s_a_a_ab\" > From Side a and Angles a, b </option> <option value= \"s_c_a_ab\" > From Side c and Angles a, b </option> </param> <effect> <object-type> all </object-type> <effects-menu> <submenu name= \"Render\" /> ➏ </effects-menu> </effect> <script> <command location= \"inx\" interpreter= \"python\" > triangle.py </command> ➐ </script> </inkscape-extension> Here is a list of descriptions for above numbered lines. this line indicates it is an xml file name tag, specifies the name on submenu (Render -> Triangle) id tag, unique id of the extension param tag, specifies an input control on dialog box param tag, specifies a select control submenu tag, shows up as a submenu under Extension menu (Extensions -> Render) command tag, the name of the Python file to invoke The first line and inkscape-extension tag are boilerplate code. Every extension has those lines. Inside the inkscape-extension tag, there are name , id , param , effect , and script tags. The name tag value Triangle shows up on the submenu Render . The second level menu Render (under Extensions main menu) is specified in the submenu tag under effect -> effects-menu . The id value must be unique for each extension. We can add a namespace such as math. before the triangle to make it distinctive. The param tags represent input controls on the dialog. This Triangle extension includes two types of param element float and optiongroup . There are many other types we can use. This Inkscape wiki page has a complete list. We don't have to memorize the user interface control syntax. We use the wiki page as a reference and grep the system extension directory to find some examples. The command tag under the script element indicates that the extension code is a Python program in triangle.py file. When we click the apply button on the dialog, the triangle.py Python program will start running. The .inx file is in XML format. XML stands for extensible markup language , which is a popular file format in early 2000s. I still remember attending a seminar in college and the speaker says something like every one should learn XML and use XML . The format becomes less popular over time. The default Inkscape file format SVG is also in XML format. Python File The triangle.py file has 188 lines. Part of the content is shown below. import sys from math import acos , asin , cos , pi , sin , sqrt import inkex X , Y = range ( 2 ) def draw_SVG_tri ( point1 , point2 , point3 , offset , width , name , parent ): ... ...... def draw_tri_from_3_sides ( s_a , s_b , s_c , offset , width , parent ): if is_valid_tri_from_sides ( s_a , s_b , s_c ): a_b = angle_from_3_sides ( s_a , s_c , s_b ) a = ( 0 , 0 ) b = v_add ( a , ( s_c , 0 )) c = v_add ( b , pt_on_circ ( s_a , pi - a_b )) c [ 1 ] = - c [ 1 ] offx = max ( b [ 0 ], c [ 0 ]) / 2 offy = c [ 1 ] / 2 offset = ( offset [ 0 ] - offx , offset [ 1 ] - offy ) draw_SVG_tri ( a , b , c , offset , width , 'Triangle' , parent ) else : inkex . errormsg ( 'Invalid Triangle Specifications.' ) class Triangle ( inkex . EffectExtension ): def add_arguments ( self , pars ): pars . add_argument ( \"--s_a\" , type = float , default = 100.0 , help = \"Side Length a\" ) pars . add_argument ( \"--s_b\" , type = float , default = 100.0 , help = \"Side Length b\" ) ... pars . add_argument ( \"--mode\" , default = '3_sides' , help = \"Side Length c\" ) def effect ( self ): tri = self . svg . get_current_layer () offset = self . svg . namedview . center self . options . s_a = self . svg . unittouu ( str ( self . options . s_a ) + 'px' ) self . options . s_b = self . svg . unittouu ( str ( self . options . s_b ) + 'px' ) self . options . s_c = self . svg . unittouu ( str ( self . options . s_c ) + 'px' ) stroke_width = self . svg . unittouu ( '2px' ) if self . options . mode == '3_sides' : s_a = self . options . s_a s_b = self . options . s_b s_c = self . options . s_c draw_tri_from_3_sides ( s_a , s_b , s_c , offset , stroke_width , tri ) elif self . options . mode == 's_ab_a_c' : ... ...... if __name__ == '__main__' : Triangle () . run () The last two lines of the file is the main entry point. The Python program initializes an instance of Triangle class and calls the run method. The Triangle class itself only defines two methods add_argument and effect , so the run method must be inherited from other classes. The Triangle class inherits EffectExtension class of inkex module. The Python modules are in the inkex subdirectory of system extension directory. The inkex is the most basic module of Inkscape extension system. It acts like a framework ( API ) upon which we build user extensions. Here are directory names and file names under the inkex directory. The first column shows that it is a directory (dir) or number of lines for a Python file. (dir) deprecated-simple (dir) elements (dir) tester 33 ./__init__.py # line of code | file name 377 ./base.py 425 ./bezier.py 474 ./colors.py 233 ./command.py 403 ./deprecated.py 378 ./extensions.py 50 ./inkscape_env.py 214 ./inx.py 66 ./localization.py 1672 ./paths.py 100 ./ports.py 382 ./styles.py 1116 ./transforms.py 120 ./turtle.py 76 ./tween.py 107 ./units.py 209 ./utils.py 6435 total 3 directories, 18 files The EffectExtension class is defined in the extensions.py file, but it's just a subclass of SvgThroughMixin and InkscapeExtension . Pay attention to the docstring of the class, which summarizes what this class does. class EffectExtension ( SvgThroughMixin , InkscapeExtension ): \"\"\" Takes the SVG from Inkscape, modifies the selection or the document and returns an SVG to Inkscape. \"\"\" pass The SvgThroughMixin and InkscapeExtension classes are defined in the base.py file. The run method is defined in InkscapeExtension class. The code is shown below. def run ( self , args = None , output = stdout ): # type: (Optional[List[str]], Union[str, IO]) -> None \"\"\"Main entry point for any Inkscape Extension\"\"\" try : if args is None : args = sys . argv [ 1 :] self . parse_arguments ( args ) if self . options . input_file is None : self . options . input_file = sys . stdin if self . options . output is None : self . options . output = output self . load_raw () self . save_raw ( self . effect ()) except AbortExtension as err : err . write () sys . exit ( ABORT_STATUS ) finally : self . clean_up () Logging Experiment Let's add some logging code to this file and check logging output. If you are not familiar with Python logging module, check out the Python Logging Howto Page . This 15 minutes youtube video explains the basics of logging module very well. In order to modify files in the system extension directory, we need to change the directory and file permissions. Run those bash commands when you are in the system extension directory. Be sure to make a copy of the directory before modifying files. $ cd /usr/share/inkscape/extensions $ sudo chmod -R 777 ../extensions/ If you install inkscape via snap , you will have a difficult time modifying any files under /snap directory. This is a security feature of snap apps. How do I know it? I waste several hours trying various methods but fail to modify permissions. In the end I simply uninstall the snap app and reinstall Inkscape through apt commands . Add those lines at the top of base.py to setup logging module. You need to change the filename directory if you are following this example. from .localization import localize # setup logging import logging # change filename path logging . basicConfig ( filename = '/home/george/Desktop/new-logging.txt' , filemode = 'w' , format = ' %(levelname)s : %(message)s ' , level = logging . DEBUG ) Then add six logging debug output lines in the run method. def run ( self , args = None , output = stdout ): # type: (Optional[List[str]], Union[str, IO]) -> None \"\"\"Main entry point for any Inkscape Extension\"\"\" logging . debug ( 'run starts' ) ##1 logging . debug ( f 'python exec: { sys . executable } ' ) ##2 try : if args is None : args = sys . argv [ 1 :] self . parse_arguments ( args ) if self . options . input_file is None : self . options . input_file = sys . stdin if self . options . output is None : self . options . output = output logging . debug ( f 'sys argv: { sys . argv } ' ) ##3 logging . debug ( f 'input : { self . options . input_file } ' ) ##4 logging . debug ( f 'output : { self . options . output } ' ) ##5 self . load_raw () self . save_raw ( self . effect ()) except AbortExtension as err : err . write () sys . exit ( ABORT_STATUS ) finally : self . clean_up () logging . debug ( 'run ends' ) ##6 The results of logging in the new-loggin.txt file are DEBUG: run starts DEBUG: python exec: /usr/bin/python3 DEBUG: sys argv: ['triangle.py', '--s_a=100', '--s_b=100', '--s_c=100', '--a_a=60', '--a_b=30', '--a_c=90', '--mode=3_sides', '/tmp/ink_ext_XXXXXX.svgVYXM70'] DEBUG: input : /tmp/ink_ext_XXXXXX.svgVYXM70 DEBUG: output : <_io.BufferedWriter name='<stdout>'> DEBUG: run ends Between the load_raw and save_raw method calls, there is an effect method call. The effect method is defined in the InkscapeExtension class, but it raises an NotImplementedError exception. The method is a placeholder for subclasses to override. The effect method in Triangle class overrides it. The InkscapeExtension class defines a debug method. We can invoke this method to output messages. The method redirects a message to the standard error stream, and Inkscape will display the message on a dialog box. However, the logging module is more flexible to use. The debug method is designed to deliver a message to an extension user. What's Next You may feel overwhelmed or even frustrated by now if you are not familiar with Python. Most Python introductory books do not even cover classes. But keep reading and experimenting, and the code will gradually make sense to you. Like most things in the programming world, it's better to learn a little and start working on something. There may be things that you don't understand, but you shouldn't wait to start because you probably will never understand everything. The extension Python code is all open source and available to you. You are free to experiment and modify it as you like.","tags":"extension","url":"https://www.inkscapetutorial.org/triangle-extension-code.html","loc":"https://www.inkscapetutorial.org/triangle-extension-code.html"},{"title":"Get Started With Inkscape Extension","text":"What Is Inkscape Extension? Before we start developing Inkscape extensions (or plugins), let's look at one simple built-in extension and understand what's an Inkscape extension. After we launch Inkscape, click menu Extensions -> Render -> Triangle... . A new dialog will pop up on screen and it looks like this. If we click the apply button, the extension will draw a triangle on the Inkscape canvas. The three sides of the triangle are all of 100 px length. We can also toggle the live preview box on to show a preview of the triangle. Obviously when the Mode is set to From Three Sides on the dialog, the extension program ignores the three Angle values. Let's change the Side length a (px) value to 50 and re-apply the extension. The program will draw a triangle like this. We know the side on the right hand is a . Next let's try to enter an invalid number and see the result. Change the Side length a (px) value to 250. Note the length of a triangle side can't be longer than the sum of other two sides. The program will generate this error message. What Extensions Can Do? The Inkscape itself comes with many extensions which are listed under the Extensions menu. Some of the extensions are intuitive to use such as Gear , Grid , and Calendar . The real power of the Inkscape extension system is that we can treat it as an API (Application Programming Interface). It provides many classes and functions on which programmers can build user extensions. WriteTeX is an extension serving as a LaTeX/TeX editor for Inkscape. We can insert math equations onto an Inkscape drawing with this tool. Here is an example drawing with equations on the right hand side. The drawing below shows a small portion of a large sign poster file which is created with an Inkscape extension. The full size poster file contains about 700 sign drawings. Extension Programs Most Inkscape extensions are written in Python programming language. If you are not familiar with Python, the official python tutorial is a good start point. Let's find out where the extension programs are located. Click the menu Edit -> Preferences in Inkscape and choose System on the left panel. We can find two extension directory settings. The value in User extensions field is shown below. /home/george/.config/inkscape/extensions And below is the value of Inkscape extensions field. We also call this system extensions directory. /usr/share/inkscape/extensions My computer runs Ubuntu 21.04 OS , and Inkscape 1.1 is installed through apt commands as suggested on this webpage . If you are running Inkscape under other OS , the directories will be different. In Windows, the two directory paths look like the two lines shown below. C:\\Users\\<User Name>\\AppData\\Roaming\\inkscape\\extensions D:\\app_work\\inkscape-1.1-x64\\inkscape\\share\\inkscape\\extensions The user extensions refers to extensions created by you as an Inkscape user (or programmer). The inkscape extensions or system extensions refers to the programs that come with the Inkscape installation. We could put our extensions in the inkscape extensions directory and vice versa. They will run just fine. But it is better to separate them into two directories. We can add two aliases to the ~/.bashrc file to have easier access to those two directories when we are developing extensions in Ubuntu. This is for Linux users only. alias cdsysdir='cd /usr/share/inkscape/extensions' alias cduserdir='cd ~/.config/inkscape/extensions' System Extensions Let's check the system extensions directory and see what is in there. The Linux commands below show that the directory has a total of 554 files and 226 Python files. The fourth command below indicates that the Python files have a total of 43,979 lines of code for Inkscape 1.1. cd /usr/share/inkscape/extensions find . -type f | wc -l # 554 find . -name '*.py' | wc -l # 226 find . -name '*.py' -exec wc -l '{}' + #43,979 The system extensions have lots of code, and it's almost impossible for one person to read and understand all of them. This extension tutorial series will try to discuss and explain a small subset of those files. If you want to take part in developing or improving system extensions, this gitlab source code repository is the place to get started. https://gitlab.com/inkscape/extensions/ Inkscape Version and Extension Inkscape versions 0.91 and 0.92 already come with many extensions. However they are mostly written in Python 2. Even though Python 3.4 is released back in 2014 and many people have been writing programs in Python 3. Inkscape extensions are in Python 2 for many years. The reason is that most system extensions are created by various developers over time and it requires some serious work to convert them to Python 3. The root problem is that Python 3 is not compatible with Python 2. Finally with the Inkscape 1.0 release, the extensions are upgraded to Python 3. The Inkscape 1.1 extensions require Python 3.6 and above. The drawback is that new extensions (third party) for Inkscape 1.0 & 1.1 are incompatible with older Inkscape, and old extensions are incompatible with new Inkscape. If you somehow get an old Inkscape extension which does not work in Inkscape 1.1, try to load it in Inkscape 0.92.X and it may work well. Objectives This tutorial series is developed from my notes. It's not as formal as a typical book or software manual, but it's in a much better shape than my notes. I am trying to point the right direction for people who are interested to learn more about Inkscape extension development.","tags":"extension","url":"https://www.inkscapetutorial.org/extension-get-started.html","loc":"https://www.inkscapetutorial.org/extension-get-started.html"}]};